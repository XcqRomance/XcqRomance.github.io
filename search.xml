<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从面试官角度给面试者几点建议]]></title>
    <url>%2F2020%2F07%2F25%2F2020-07-25%2F</url>
    <content type="text"><![CDATA[年初的时候我参加了公司的面试官培训，到今天为止也面试了一些人。在此总结下自己的面试心得，本文主要从面试官礼仪、面试考查内容、面试者需要注意的点三个方面入手，希望对面试者或者面试官有所启发。今年由于疫情，很多公司倒闭，简历收到很多，面试都是通过在线视频面试，并没有现场面试，再加上自己面试人数还不够，所以一些观点看法难免浅陋。 面试官礼仪：面试官代表着公司企业的形象，然而在实际面试中一些面试官往往忽视一些细节问题，进而给面试者不好的体验，甚至给企业造成负面的影响。所以作为面试官要注意一些基本的面试礼仪，给面试者好的体验。说一个自己之前去面试一家公司一个不太好的体验例子：面试官穿着一双拖鞋，头发油腻而且的头屑比较多。这给了我很不好的面试体验，我直接拉黑了这家公司首先，所以必须得注重自己的仪容仪表，不要求化妆和穿正装，但是必修得穿着得体、干净整洁、精神风貌好；其次，面试时间必须准时，如果迟到必须得像面试者说明情况和缘由；再次，在面试过程中要最终面试者，不要心不在焉，做一些与面试无关的事情，比如用手机、电脑处理其他事情，如果有紧急事情要处理也应该事前和面试者说明。 面试考查内容：面试考查内容因人而异，因面试岗位不同也不同，一般面试官都会准备一些题目，同时结合面试者简历进行提问。一般的面试都是3轮技术+一轮HR。一轮面试一般40-45分钟，而且每一轮技术面试都拥有一票否定权。面试原则是宁缺毋滥，当我们不确定面试者是否合适一般都是直接fail掉。总体而言，面试官主要考察这两个方面：硬实力和软实力。 硬实力主要包括下面五个方面，其中前三个方面是必须过关，否则直接fail 编码能力 这个主要考察面试者的代码实操能力和在有限时间内完成一个简单的coding题目，代码量一般不大20-30行之间。作为一个面试者对于leetcode上面的中等偏下的题目是必须得掌握的，至少得熟悉常用题谬的解法和思路。但是面试过程中不一定遇到原题。 算法和数据结构 这个必须的要掌握的，不管是几年经验的面试者都得看下他的基本功。算法的时间、空间复杂度得基本掌握，常用的数据结构熟悉使用和应用场景。以一个简单的数组为例，面试官不太可能问概念性的问题，而是通过实际的代码来考察对他的掌握程度。 计算机基础知识（操作系统、网络、数据库） 这点对于非计算机专业的同学来说一个弱项，因为没有学过对应的专业课的话很难回答一些底层知识点，面试过两个非计算机专业同学，这方面的知识都回答的不好，一般都是直接fail。 语言平台方面 以iOS为例，得熟悉掌握Objective-C和swift的运用以及语言特性相关的内容，比如runtime，runloop等； 实际项目 这个主要考察面试者实际项目中用到的技术点，为了从面试者的回答中获取更多信息以及从面试者的回答进行深度提问，面试官一般都是通过STAR进行提问，Situation：当时是什么情况？Task：你的角色是什么？Action：你做了什么？Result：取得了什么结果。 iOS相关的学习资源汇总可以见我在简书上面的iOS学习提升资源汇总 软实力卡耐基曾经说过，一个人的成就只有15%于他的专业技能相关，另外85%屈取决于他的软实力。主要包括三个方面 沟通表达能力 潜力 积极主动性 面试者注意点： 准时，基本的仪容仪表； 硬实力一定要过关； 建立自己的个人影响力，通过注入博客、github、等平台充分展示自己，面试官也可以全方位的了解你； 充分把握向面试官提问的机会；我面试的几个面试者，有人询问，你刚刚题目的答案是这样的，能给我讲一下吗？我还有下一轮面试吗，总共有几轮面试？等等这类问题，这些提问很是浪费了一个良好了解你所应聘岗位、团队、公司的提问。可以咨询一些诸如此类的问题： 团队现状和发展情景；目前团队项目使用的技术栈，开发流程；开发工具之类；如果入职了，你这个职位的期望；当前业务的如何支撑公司的发展]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的2019年个人总结]]></title>
    <url>%2F2020%2F01%2F02%2F2020-01-02%2F</url>
    <content type="text"><![CDATA[时间飞逝，转眼2020年，记录下自己2019年的个人总结，主要从工作、家庭、生活、健康方面展开。 工作：在字节跳动的个人成长很快，和优秀的人一起共事，学习到同事们的做事方法和问题解决能力，随着项目的发展能够跟随团队一起成长。往回看，自己从2019年3月从滴滴离职加入字节跳动是一个很好的选择，很感谢滴滴，在滴滴的六个多月里，自己也学习到了很多东西，特别是技术方面，工程代码设计以及工程架构设计相关。但对比滴滴和字节跳动，字节跳动的成长更大，两个公司的文化，价值观都迥然不同，尽管二者都很年轻，但是让我感觉字节跳动是一个更加年轻化的公司，对于年轻人的成长提升更快，字节不设title，不看工龄，全看个人能力；而且在跨部门和写作上效率更高。在字节的9个月里，自己按时保质完成了将近15个业务、技术需求，对于个人业务能力和技术能力有了很大的提升。团队拥有优秀的leader和团队成员，有标准的流程规范，让自己能够更加专注的做自己的事情，团队之间会在周会上定期分享交流，能够学到不少的知识。转正之后自己也开始作为mentor带新人，在此之前，组内还专门进行开会讨论并且制定了新人培养计划，制定了一套完备的体系，这其中包括个人成长：知识体系搭建、流程规范、代码实践等；人文关怀：沟通反馈、团队融入、公司文化、身份转变；职业前景介绍：职业规划，行业介绍。主要是就是帮助新人尽快成长，培养成为一名优秀优秀的工程师，为公司注入新鲜的血液。自己在工作的时候多的这一重身份，也让自己得到了学习成长。 家庭：2019年2月14日是我结婚的日子，和妻子也相处的很好，结婚前后的生活变化并不大，尽管蜗居在一个不到15平米的房间里，但我们也感觉很幸福，偶尔的小打小闹我就当做我们夫妻之间的八十一难，并不会影响我对老婆的爱，平时由于工作上繁忙和时间的错开，加上周末还得去学校上课，我们两个人相处的时间并不多。除了国庆去了广州看爸妈的时候游玩了下，没有去过其他什么地方。这也幸苦了我家老婆，没能满足她哪怕是小小的一个游玩的心愿，但我坚信我一定能够给她带来幸福。父母也日趋衰老，从视频的举手投足之间都能感受到，一年也就只能一两次的见面，不过庆幸的是，给他们体检的结果上来看比去年相对来说健康些，对于父母，只希望他们身体健康，就是我最大的心愿。对于玉爸和奶奶也是希望他们俩身体健康，可惜父母那一辈闲不下来，总是希望挣些钱，减轻子女负担，还很勤俭节约，对于他们而言这是他们这一代人的特点，说多了他们也不听，我能做的就是努力奋斗，创造好的生活给它们，让他们都养老无忧。成立家庭之后，明显感到了肩上的责任和压力，同时理解了父辈们的心酸不易。 生活：这一年基本都献给了工作，周末献给了学校，没什么个人生活，过的非常充实，周末能够在家做个饭也是一种惬意。于是我经常想这样的生活是我所想要的吗，我的答案是，否。正因如此我想要改变这样的生活就必须要努力提升自己。考上了北理的MEM之后，发现和自己预期还是有些偏差，学习的内容更加偏向于工程方面，和我从事的互联网行业并非很相符。不过既要工作又要学习，这样的生活真是着实的累。 健康：身体体检相比于去年更加健康了，体重相比于去年同时间也减轻了4斤，尽管工作很忙，自己还是会保证一周健身三次，一次40分钟以上。还给自己买了定期寿险，毕竟成家之后多了一份责任，让自己工作无后顾之忧。 2020年的计划 多点个人生活，和老婆一起周边走走，多点和她相处的时间；偶尔给她制造点惊喜，保持婚姻的甜蜜； 脚踏实地，在专业技术上更加深入一步，研究llvm。工作上保证业务质量，无线上事故； 坚持健身，每周三次，一次45分钟以上； 完成学业，坚持上课，思考，交流； 参加公司面试官培训，作为一个面试官面试选拔优秀人才，记录总结自己的面试题库； 多读书：看技术书籍：3本以上，并且记录文档。非技术的书籍：10本以上。并且总结形成文档； 新人培养，团队分析，甚至跨团队分享。]]></content>
  </entry>
  <entry>
    <title><![CDATA[代码质量分析利器OCLint]]></title>
    <url>%2F2019%2F05%2F01%2F2019-05-01%2F</url>
    <content type="text"><![CDATA[前言随着团队人员的增多，开发人员的编码风格不一致带来的开发效率的低下，以及编写代码中容易犯错的一些问题，尽管在人工code review 的能够发现并且解决，但是效率将会大大降低，而且依靠人工来保证项目代码质量本身就不牢靠。我们必须在编码阶段，打包交付测试前就发现编写代码的潜在问题，并且解决这些问题来提高工程代码质量。 本文就是笔者在实际项目中运用OCLint对整个项目进行的一次实践，记录在实践过程中的思路和所遇到的坑点，分享给大家。 笔者的所使用的开发工具和和开发环境如下：123456Mac系统版本：macOS Mojave 10.14.5ruby版本：2.6.3p62gem版本：3.0.3Xcode版本： 10.2.1OCLint版本： 0.13xcpretty版本： 0.3.0 # 这个是在项目文件夹下使用gem配置了的本地ruby环境安装的，后面会说明为啥不安装在系统默认的ruby环境下 笔者使用OCLint所做的codereview是结合Xcode在编码开发阶段进行的，ocline结合xcode的配置教程，这么做的优点是：能够在在开发阶段发现编写代码的潜在问题，把问题提前暴露出来。缺点就是会：延长开发编译时长，降低开发效率。 再讲如何安装OCLint和使用之前，我先讲一下衡量代码质量的几个指标： 代码质量衡量指标 Cyclomatic Complexity：循环复杂度（又叫圈复杂度），用来表示程序的复杂度，圈复杂度越高，代码就越难复杂难维护。OCLint给的默认阈值是10。复杂度计算：M = E − N + 2P，其中 E 为图中边的个数，N 为图中节点的个数，P 为连接组件的个数。简单程序的控制流图。此程序由红色的节点开始运行，然后进入循环（红色节点下由三个节点组成），离开循环后有条件分支，最后运行蓝色节点后结束，此控制流图中，E = 9, N = 8, P = 1，因此其循环复杂度为 9 - 8 + (2*1) = 3。具体可见维基百科介绍 和 这篇文章的计算方法。下面我用例子介绍一个简单的计算方式：如下例子：下面这段代码的 M = 2(if) + 1(for) + 1(for) + 2(if) + 2(if) + 2(if) + 1 = 11. 1234567891011121314151617181920212223242526272829303132333435363738394041- (UIBezierPath *)pathForRect:(CGRect)rect &#123; UIBezierPath *path = [[UIBezierPath alloc] init]; if (self.width &lt; 1.0) &#123; self.width = self.segments.firstObject?self.segments.firstObject.width:1; &#125; NSArray *segments = [_segments copy]; xxxxxSegment *lastSegment = nil; xxxxxPoint *lastPoint = nil; for (xxxxxSegment *segment in segments) &#123; xxxxxPoint *firstPoint = nil; for (xxxxxPoint *point in segment.points) &#123; if (!firstPoint) &#123; firstPoint = point; if (!lastSegment) &#123; [path moveToPoint:CGPoint(point)]; [path addLineToPoint:CGPoint(point)]; &#125; else &#123; xxxxxPoint *lastPoint = lastSegment.points.lastObject; if (![lastPoint isEqual:firstPoint]) &#123; [path addLineToPoint:CGPoint(lastPoint)]; [path moveToPoint:CGPoint(firstPoint)]; &#125; else &#123; [path addQuadCurveToPoint:MID_CGPoint(lastPoint, firstPoint) controlPoint:CGPoint(lastPoint)]; &#125; &#125; &#125; else &#123; NSAssert(lastPoint, @&quot;last point should not be nil&quot;); [path addQuadCurveToPoint:MID_CGPoint(lastPoint, point) controlPoint:CGPoint(lastPoint)]; &#125; lastPoint = point; &#125; lastSegment = segment; &#125; if (lastPoint) &#123; [path addLineToPoint:CGPoint(lastPoint)]; &#125; return path;&#125; NPath Complexity：NPath复杂度，用来表示一个方法所有可能执行路径的总和。OCLint给的默认阈值是200。NPath复杂度越高，代码越难以被理解。例子：下面的例子NPath复杂度为4。 12345678910111213141516void example() &#123; if (xx) // 1 &#123; &#125; else // 2 &#123; &#125; if (xx) // 1 &#123; &#125; else // 2 &#123; &#125;&#125; Non Commenting Source Statements：除去空语句，注释代码之后的源代码行数。OCLint给方法的默认阈值是30，给一个类文件的默认阈值是1000。当NCSS过高，代码的维护成本就会提高，此时就得考虑方法和类的瘦身，进行拆分和重构。例子： 123456789void example() // 1&#123; if (1) // 2 &#123; &#125; else // 3 &#123; &#125;&#125; Statement Depth：语句嵌套深度。OCLint给方法的默认阈值是5。例子： 1234567if (1)&#123; // 1 &#123; // 2 &#123; // 3 &#125; &#125;&#125; 为什么选择则OCLintiOS静态代码分析工具对比： Xcode自带的Analyzer，使用方式超级简单Product &gt; Analyze或者快捷键shift + command + B。能够进行以下的问题检测，支持的语言包括C, C++ 和 Objective-C，不可进行自定义；•逻辑缺陷，例如访问未初始化的变量和解除引用空指针；•内存管理缺陷，例如内存泄漏；•未使用的变量；•由于不遵循项目使用的框架和库所需的策略而导致的API使用缺陷。 Facebook开源的Infer，使用方式用command line，可以持续集成能够检查的bug类型比Analyzer丰富，具体见官方文档。 OCLint, 优点是可检查的规则最多，并且具有高可定制性，缺点是集成到Xcode中进行检测效率低。官方定义的支持的检查规则有71条，详见官方规则。以上三个工具的底层原理都类似，都需要用到Clang进行码编译后的产物，然后进行分析。综上比较，因OCLint的可定制化最高，并且可以和Xcode无缝结合，所以我们团队选择使用OCLint可以非常方便和统一的进行项目工程代码质量检测并且修改。 OCLint安装官方文档上提供了三种安装方式了，分别是：Homebrew、下载安装包安装、源代码编译安装；如果需要自定义检测规则，则必须使用第三种安装方式：源代码编译安装。不过笔者尚未尝试过，到后期根据团队的项目实际需要，如果需自定义则会尝试使用。笔者使用的是最简单的Homebrew安装方式：12brew tap oclint/formulaebrew install oclint 有以下信息则表示安装成功123$ oclintoclint: Not enough positional command line arguments specified!Must specify at least 1 positional arguments: See: oclint -help xcpretty安装由于笔者使用方式是直接在xcode的Build Pahses添加的Run Script脚本，在使用gem install xcpretty的安装方式在系统的ruby环境安装会在编译的时候会报错，xcpretty command not found，原因就是xcode和teminal的环境不一样，尽管在terminal上能很好工作但是在xcode就会报找不到xcprrety的错误。当时找到的一种解决方式直接在sh脚本中将xcpretty写为绝对路径（找到安装的绝对路径就是which xcpretty），但是这种方式的弊端就是组内成员没法协同开发，毕竟比无法保证其他伙伴安装的xcpretty的绝对路径和你的保持一致，座椅最终放弃这种方式。最后在询问团队其他人员的协助下找到了另一个解决方案：使用bundler在工程目录维护一个管理ruby gem，详细介绍见官方文档。首先安装bundler，在终端执行如下命令：1gem install bundler 在xcode工程根目录写一个Gemfile，内容如下12source &apos;https://rubygems.org&apos;gem &apos;xcpretty&apos;, &apos;0.3.0&apos; 然后执行1bundle install 执行完成后，会有一个ruby文件夹的生成，这个就是本地的ruby环境，xcpretty就安装完成。 .oclint 规则配置文件编写官方可配置的71条规则在项目根目录编写一个.oclint文件，笔者的项目使用的规则内容如下：123456789101112131415161718192021222324252627282930313233343536rule-configurations: - key: CYCLOMATIC_COMPLEXITY # Cyclomatic complexity of a method 10 value: 30 - key: LONG_LINE value: 110 - key: NCSS_METHOD # Number of non-commenting source statements of a method 30 value: 50 - key: LONG_VARIABLE_NAME value: 40 - key: NESTED_BLOCK_DEPTH value: 6 - key: MINIMUM_CASES_IN_SWITCH value: 2 - key: SHORT_VARIABLE_NAME value: 1 - key: TOO_MANY_METHODS value: 50 - key: LONG_METHOD value: 100disable-rules: - RedundantLocalVariable - SHORT_VARIABLE_NAME - LongVariableName - UnnecessaryElseStatement - RedundantNilCheck - RedundantIfStatement - InvertedLogic - AssignIvarOutsideAccessors - UseObjectSubscripting - BitwiseOperatorInConditional - PreferEarlyExit - UnusedMethodParametermax-priority-1: 1000max-priority-2: 1000max-priority-3: 1000enable-clang-static-analyzer: false sh脚本编写内容如下：1234567891011121314151617181920212223242526272829# Type a script or drag a script file from your workspace to insert its path.export LC_CTYPE=en_US.UTF-8set -euo pipefail # 脚本只要发生错误，就终止执行# 删除DerivedData的build文件#echo $(dirname $&#123;BUILD_DIR&#125;)rm -rf $(dirname $&#123;BUILD_DIR&#125;)# 1. 环境配置，判断是否安装oclint，没有则安装if which oclint 2&gt;/dev/null; thenecho 'oclint already installed'else # install oclintbrew tap oclint/formulaebrew install oclintfi# 2.0 使用xcodebuild构建项目，并且使用xcprretty将便于产物转换为jsonprojectDir=$&#123;PROJECT_DIR&#125;prettyPath="$&#123;projectDir&#125;/ruby/2.6.0/gems/xcpretty-0.3.0/bin/xcpretty" # 替换为你安装的本地路径#echo $&#123;prettyPath&#125;projectName="xxxxxxx" # 替换为你的project namexcodebuild -scheme $&#123;projectName&#125; -workspace $&#123;projectName&#125;.xcworkspace clean &amp;&amp; xcodebuild clean &amp;&amp; xcodebuild -scheme $&#123;projectName&#125; -workspace $&#123;projectName&#125;.xcworkspace -configuration Debug -sdk iphonesimulator COMPILER_INDEX_STORE_ENABLE=NO | $&#123;prettyPath&#125; -r json-compilation-database -o compile_commands.json# 3.0 判断json是否if [ -f ./compile_commands.json ]; then echo "compile_commands.json 文件存在";else echo "-----compile_commands.json文件不存在-----"; fi# 4.0 oclint分析jsonoclint-json-compilation-database -e Pods -- -report-type xcode 然后command + B之后，去喝泡一杯咖啡，回来你就能够看到工程代码的warning然后修改代码。 Clang-format对团队代码进行风格统一笔者使用的.clangformat的配置如下，具体见gist：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687---# Language: ObjCBasedOnStyle: GoogleAccessModifierOffset: 0ConstructorInitializerIndentWidth: 4SortIncludes: false# 连续赋值时，对齐所有等号# AlignConsecutiveAssignments: true AlignAfterOpenBracket: trueAlignEscapedNewlinesLeft: trueAlignOperands: falseAlignTrailingComments: trueAllowAllParametersOfDeclarationOnNextLine: falseAllowShortBlocksOnASingleLine: falseAllowShortCaseLabelsOnASingleLine: falseAllowShortFunctionsOnASingleLine: falseAllowShortIfStatementsOnASingleLine: false # AllowShortFunctionsOnASingleLine: AllAllowShortLoopsOnASingleLine: falseAlwaysBreakAfterDefinitionReturnType: falseAlwaysBreakTemplateDeclarations: falseAlwaysBreakBeforeMultilineStrings: falseBreakBeforeBinaryOperators: NoneBreakBeforeTernaryOperators: falseBreakConstructorInitializersBeforeComma: falseBinPackArguments: trueBinPackParameters: trueColumnLimit: 110ConstructorInitializerAllOnOneLineOrOnePerLine: trueDerivePointerAlignment: falseExperimentalAutoDetectBinPacking: falseIndentCaseLabels: trueIndentWrappedFunctionNames: falseIndentFunctionDeclarationAfterType: falseMaxEmptyLinesToKeep: 1 # 连续的空行保留几行KeepEmptyLinesAtTheStartOfBlocks: falseNamespaceIndentation: InnerObjCBlockIndentWidth: 4ObjCSpaceAfterProperty: trueObjCSpaceBeforeProtocolList: truePenaltyBreakBeforeFirstCallParameter: 10000PenaltyBreakComment: 300PenaltyBreakString: 1000PenaltyBreakFirstLessLess: 120PenaltyExcessCharacter: 1000000PenaltyReturnTypeOnItsOwnLine: 200PointerAlignment: RightSpacesBeforeTrailingComments: 1Cpp11BracedListStyle: trueStandard: AutoIndentWidth: 4TabWidth: 4UseTab: NeverBreakBeforeBraces: CustomBraceWrapping: AfterClass: true AfterControlStatement: false AfterEnum: false AfterFunction: false AfterNamespace: true AfterObjCDeclaration: false # ObjC定义后面是否换行 AfterStruct: false AfterUnion: false BeforeCatch: false BeforeElse: false IndentBraces: falseSpacesInParentheses: falseSpacesInSquareBrackets: falseSpacesInAngles: falseSpaceInEmptyParentheses: falseSpacesInCStyleCastParentheses: falseSpaceAfterCStyleCast: falseSpacesInContainerLiterals: trueSpaceBeforeAssignmentOperators: trueContinuationIndentWidth: 4CommentPragmas: '^ IWYU pragma:'ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]SpaceBeforeParens: ControlStatementsDisableFormat: false... 使用命令clang-format -i [files]]]></content>
  </entry>
  <entry>
    <title><![CDATA[再读《逆转》，程序员如何度过这个寒冬]]></title>
    <url>%2F2019%2F01%2F27%2F2019-01-20%2F</url>
    <content type="text"><![CDATA[第一次读《逆转》这本书是在当初毕业没多久在亚马逊买了格拉德威尔系列书籍，其他几本是：《大开眼界》、《异类》、《眨眼之间》、《引爆点》。三年多后重读这本书，发现里面的大多数内容都忘了😂，所以决定对于今后读的书籍写一个自己的总结，并且结合书中的知识说下该如何度过这个互联网寒冬。 《逆转：弱者如何找到优势，反败为胜？》最核心的观点就是：随着环境的变化，有些劣势可以转化为优势，有些旁人看来得优势其实是劣势。掌握’以弱胜强’的内在逻辑，弱者就能反败为胜。 文章首先通过三千年前发生在以拉山谷的历史战役：巨人歌利亚和牧童大卫的战斗以大卫胜利的故事引出了两个观点，第一：一些我们看来有价值的东西往往产生于不平衡的冲突中；第二：我们对这些冲突的理解常常是错误的。具体的分析如下：巨人并不像我们想的那样强大，他是重装步兵，身材巨大（肢端肥大症），视觉重影，移动速度超级慢，而大卫则是以速度取胜，他是有经验的投石手，而且他并不计划和对方近距离徒手搏斗，而是远程投射对方的额头（巨人唯一的弱点）。 其次是通过介绍一直篮球队教练维威克·拉纳迪夫和他女儿安佳丽所在的弱队，通过压迫式打法：全场紧逼，限制对方发球和运球过半场，取胜比他们强的球队，最终获得全国冠军。通过这个例子作者说明，如果对手比你强很多，不要和对方直接正面的硬碰硬，这样毫无胜算，只有剑走偏锋才有取胜的可能。不按对手的套路出牌，是你处于劣势的时候必须要做的一个选择。 看了上面的例子，我并没被说服，毕竟在我看了只是个例，不具有普遍性，通过个例就得结论未免有些以偏概全。 但接下来作者就通过数据说明了劣势和优势可以相互转化让我信服。书中通过一个家庭的财富与家庭教育的关系、班级人数和学生成绩之间、权利的运作的数据分析得出倒U形曲线理论，它包括三个部分：左半部分表明做的更多或者拥有更多能让事情变得更好，平坦的中间部分表示d做多做少并不能改变多少，右半部分表示做的更多或者拥有更过的财富会让事情变得更糟，通俗的解释就是更多并不意味着更好。文中还引申出富人家庭教育孩子，父母教育孩子要学会从说‘我们买不起’转变说‘我们不会买’。 总之，通过读这本书，我对优势和劣势有个进一步的认识，没有永远的优势和劣势，优势和劣势可以相互转化，弱者想要战胜强者，必须使用非常规的战术。对应工作中，我的启示是：自己的iOS开发经验4年，在面对同一个岗位竞争的时，对比真正资历深厚的程序员而言，自己的劣势就是：技术经验可能不如人家。但是自己的优势就是年轻，有激情有干劲，薪水也比人家低，未来的可塑性比较强。在面试过程中就得展示自己的这些优势。但随着时间、环境的变化，自己的年轻优势也将不复存在，到那时又该如何保持建立自己的独特优势和壁垒呢？我的答案是：持续学习，提升自己的硬实力（专业领域知识）和软实力（方法、沟通、学习能力、人脉资源）。 特别是在目前移动互联网已经到了下半场，最近互联网裁员风波一波未平一波又起。如何度过这个寒冬？我的启示是：我可以从另一个角度来看待：我认为这次互联网寒冬对我们互联网从业人员来说是件好事，让人们的心里从浮躁回归理性。在太多人眼中，互联网行业是大家眼中的香馍馍，因为前几年的快速发展，导致大量的人员涌入这个行业，从此这个行业出现了太多的不理性，特别是相关的培训机构的从各行各业中给这个互联网行业输入了大量的人，原本的供需平衡被严重打破，如今寒冬的一到来，正好是刺破这一泡沫。公司为了发展开拓新业务，往往持续招聘人才，公司人员就越来越多，寒冬一来，一些边缘业务立马收缩，人员如何安置，于是多出了大量人员，但公司从不养闲人，那公司就只能优化掉这些人员，这一点正好说明了更多并不意味着更好。当行业冷却下来后，这些优化的人员出路如何，有的人会选择转行回到自己原先的行业谋求出路，一部分人选择继续在这行业发展，但他们看待这行业时是理性的，看待寒冬也是理性了，也不会不知所措。总之在寒冬中我们要正确认识自己，并且提升自己。 “智贵乎早决，勇贵乎必为。”]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018总结]]></title>
    <url>%2F2019%2F01%2F03%2F2019-01-03%2F</url>
    <content type="text"><![CDATA[2018年对互联网行业来说是一个不太平之年，上半年的P2P暴雷，全国的经济内部外部环境都不好，特别是下半年进入了寒冬期，网络上充斥着大量的互联网公司裁员消息，大公司也进行了缩招，基本上是人心惶惶，而2018年与我而言是多维度发展的一年。 首先，工作上完成了自己年初计划的目标：跳槽进入大公司。虽说好未来算是教育界的TOP2，但还是属于比较传统的行业，我在工作的两年自己成长了不少，但在后期也确实感到自己增长的瓶颈，开发的产品用户量不大，工作比较轻松，而对于我的职业发展而言无疑是不太合适的。加之自己年龄的增长带来的焦虑感，以及对自己教育背景又一般的我而言，进入一家大公司工作镀金将是是我职业发展过程中至关重要。毕竟现在对于iOS开发行业而言，企业的要求是越来越高，加上从业者越来越多，尽管你有独立开发的能力，但是如果能有一个好的企业为你背书，你将能够有更好的职业发展前景，更主要是能进入一家优秀的互联网公司，我将能够学习到更多的知识，成长的更快，进入滴滴近四个多月以来，我确实学到了收获了不少，每周都有各个领域大牛的分享会，可以向他们沟通学习。当然，工作上自己也有犯错，因为自己写的代码上的漏洞引起导致线上app的crash，QA测试没有的测试出来，对公司的造成了严重的损失，只能说吸取教训，吃一堑长一智。对于未来一年的要求就是，工作上高效的完成任务，无线上bug。 其次，学习上获得了成长，并且持续学习。这其中包括考研准备的逻辑判断和逻辑写作方面的书籍、自己购买的书籍以及各类学习app得到上面的。学习考研的逻辑让自己学会了对待任何事物需要使用批判性思维看待事物，不人云亦云。购买的实体书籍也有很多，技术书籍有：大话设计模式、大话数据结构、大话数据库、编程珠玑、数据结构和算法分析、Effective Objective-C 2.0、思考的快与慢、Objective高级编程iOS与OS X多线程和内存管理等，其中我推荐思考快与慢，再结合得到app上面的讲解，会理解的深刻一些。在极客时间这个app上面买的两个课程一个是数据结构和算法，一个是白话法律，都学习到不一样的知识，特别是学习一些法律意识能够让自己不走犯罪的道路，而是工作生活中有些法律知识能够保障自己的权益。对于2019年的要求是学习一门新的语言，拓宽自己的知识，深入学习自己的领域知识。 再次，生活不易，且行且珍惜。来北京这几年，得了鼻炎，一到雾霾天或者春季花粉季节就打喷嚏，严重时还引起感染发炎，特别难受，在医院花了近千元查了过敏原也没用，喷的药因为有激素，也不敢经常喷，怕有耐药性。犯了这毛病吧，就是特敏感，平时空气质量差点就得带着口罩，生怕加重。其他的话身体都很健康，一周至少三次运动，特别是在滴滴，健身房就在负一楼，每天中午有两个小时时间午休，可以去锻炼一个小时，中午晚上都有操课，跟着老师练习特别给力。还有就是8月份和女朋友去哈尔滨-呼伦贝尔草原-满洲里那边避暑玩耍了几天，算是结婚前的一次旅行吧，体验了北方草原的辽阔和空气的清新，吃了马奶酒，骑了马，吃了羊肉，超级爽。 最后，回头看2017年立的flag基本上是五五开，一些实现了，一些则是中途放弃了。RN没有继续深入学习，年初facebook除了消息要重构，而且自己尝试之后发现局限性还是挺啊的，特别是一些性能问题，所以没有再继续深入学习，而是将重心放在了考研学习上面，今年的flag就是身体健康、婚姻幸福，攒钱装修，工作更上一层楼。 2019将是更加严峻的一年，只能更加的砥砺前行，才能抵御这个严峻的寒冬。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS高效开发小技巧-常用代码块]]></title>
    <url>%2F2018%2F11%2F13%2F2018-11-13%2F</url>
    <content type="text"><![CDATA[做iOS开发已经将近四年，这里收录了一份自己一份高效开发的代码块，总共20个。在看WWDC大会上，也经常看到苹果的开发者在讲解代码的使用这个小技巧，其实我们日常开发中使用这个小技巧能够明显的提高我们的开发效率，避免写一些循环重复的代码，如果你还不清楚啥叫代码块，可以参考这篇文章Xcode Snippets或者Xcode Snippets中文版。 下载地址：Code Snippet，提取密码:65f7，更详细的内容可以在gist上面查看，如果你一些好用的代码块，欢迎大家评论补充和交流。 添加方法：1、在终端上执行命令：open ~/Library/Developer/Xcode/UserData/CodeSnippets/；2、解压上面下载的zip包，拷贝解压的CodeSnippets文件夹里面的所有.codesnippet的文件到第一步执行打开的目录；甚至大家可以将这个目录使用git仓库来管理，托管在GitHub上。 使用方法：所有的代码块的快捷键都是以my开头，比如在.m文件@implementation和@end范围内输入myimplementation,就会自动出现下面的模版代码 12345678910111213141516171819202122232425262728293031#pragma mark - life cycle- (instancetype)init &#123; if (self = [super init]) &#123; [self buildUI]; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; [self buildUI]; &#125; return self;&#125;- (void)dealloc &#123; &#125;#pragma mark - private method- (void)buildUI &#123; &#125;#pragma mark - public method#pragma mark - event response#pragma mark - setter &amp;&amp; getter 当然使用快捷键大家可以自定义设置]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过UML类图迅速学习SDWebImage源码设计]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-04%2F</url>
    <content type="text"><![CDATA[趁着国庆，赶紧给自己充充电，最近两天看了一本大话设计模式，里面有一节讲的是UML类图，并且重温了Objective-C编程之道，iOS设计模式解析(提取码: sj2u)，以前看各个设计模式的UML类图一直不理解，也记不住那些符号什么意思，以至于对设计模式的理解不够深入，仅仅停留在一知半解的层面上，于是结合以前看的SDWebImage的架构图和源码，对UML类图有了更近一步的了解，同时将SDWebImage的源码又学习了一遍，本文的SDWebImage版本是4.4.2 一、SDWebImage的UML类图类的表示注意：第一层表示类名，如果是抽象类就用斜体表示。第二层表示类的字段和属性。第三层表示类的方法操作。前面的符号“+”表示公有的，public；“-”表示私有的，private。如果是接口顶端会有《interface》，在iOS中即是协议，如下所示： UML中各类关系表示由上两张图可知： 依赖关系表示：使用虚线箭头，如上图以UIButton+WebCache和UIView+WebCache为例： sd_setImageWithURL依赖于sd_internalSetImageWithURL方法； 聚合关系表示：空心菱形+实线，聚合表示一种拥有关系，体现的是A对象包含B对象，但B对象不是A对象的一部分（这里后半部分定义和实际好像不一样）。在上图的SDWebImageManager和SDImageCache、SDWebImageDownloader就是一种聚合关系，表示SDWebImageManager聚合SDImageCache和SDWebImageDownloader，并且拥有这两个对象的实例，分别是imageCache和imageDownloader； 实现协议：三角形+虚线，如上图，以SDWebImageOperation协议和SDWebImageCombinedOperation类为例，SDWebImageCombinedOperation遵循SDWebImageOperation协议，并且实现了cancel方法； 组合关系，表示整体和部分的关系， 继承关系，包括子类继承父类，协议继承，上图中显示的协议继承关系。 总的UML架构图整个设计完全满足面向对象的六大原则 单一职责原则定义：一个类应该是一组相关性很高的函数、数据的封装。SDImageCache专门负责图片的缓存逻辑，SDWebImageDownloader专门负责图片下载逻辑； 开闭原则定义：对象、模块、函数对于扩展是开放，对于修改是封闭的。UML类图中的编解码模块体现了开闭原则的思想，SDWebImageImageIOCoder、SDWebImageGIFCoder、SDWebImageWebPCoder都实现了SDWebImageCoder协议所定义的图片编码解码策略。他们编解码图片的具体实现完全不一样，而且如果用户需要自定义实现编解码策略时，只需新建一个实现SDWebImageCoder协议的类。 里氏替换原则定义：所有引用基类的地方必须能透明地使用其子类对象。里氏替换核心原则是抽象，抽象又依赖于继承。同样是编解码模块，SDWebImageProgressiveCoder继承SDWebImageCoder 依赖倒置原则核心就是：面向接口编程。解释同开闭原则里说的的SDWebImageCoder协议。 接口隔离原则定义：客户端不应该依赖他不需要的接口。SDWebImageDownloader就是接口隔离运用，SDWebImageManager只需要知道该下载对象有downloadImageWithURL下载图片的接口即可。下载图片的具体实现对SDWebImageManager隐藏，他用最小化接口隔离了实现细节。 迪米特原则定义：一个对象应该对其他对象有最少的了解。通俗点讲就是：一个类应该对自己需要耦合或者调用的类知道最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或者依赖者只需要知道她需要的方法即可。UML类图中的组合，聚合，依赖关系都体现了这个原则，UIkit扩展模块就很明显的体现了这种思想，只需要知道有一个调用方法sd_setImageWithURL:能够设置图片，外部调用者（也就是程序员）不需要具体的图片下载缓存逻辑和缓存策略。 二、SDWebImage加载图片逻辑图片加载逻辑如下： 首先会在SDImageCache中以图片url作为key在内存缓存中查找，是否有对应的缓存图片UIImage；123- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123; return [self.memCache objectForKey:key];&#125; 如果内存缓存中没有找到，则会以图片url进行MD5加密后作为key在磁盘中查找。如果找到了，则会把磁盘中的数据加载到内存中，并且将图片显示出来；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// url md5加密- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123; const char *str = key.UTF8String; if (str == NULL) &#123; str = ""; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSURL *keyURL = [NSURL URLWithString:key]; NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension; NSString *filename = [NSString stringWithFormat:@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@", r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @"" : [NSString stringWithFormat:@".%@", ext]]; return filename;&#125;// 磁盘中查找图片是否存在- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123; NSString *defaultPath = [self defaultCachePathForKey:key]; NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil]; if (data) &#123; return data; &#125; // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil]; if (data) &#123; return data; &#125; NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy]; for (NSString *path in customPaths) &#123; NSString *filePath = [self cachePathForKey:key inPath:path]; NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil]; if (imageData) &#123; return imageData; &#125; // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil]; if (imageData) &#123; return imageData; &#125; &#125; return nil;&#125;NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];UIImage *diskImage;SDImageCacheType cacheType = SDImageCacheTypeDisk;if (image) &#123; // the image is from in-memory cache diskImage = image; cacheType = SDImageCacheTypeMemory;&#125; else if (diskData) &#123; // decode image data only if in-memory cache missed diskImage = [self diskImageForKey:key data:diskData options:options]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; &#125;&#125; 如果内存和磁盘缓存中都没有找到，就会向后台发送请求，下载图片；下载后的图片会缓存到内存中，并且写入磁盘中(写入磁盘得判断SDWebImageCacheMemoryOnly，这个过程在异步线程中完成)；123456789101112131415161718192021222324252627// SDWebImageManagerdispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; @autoreleasepool &#123; UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; NSData *cacheData; // pass nil if the image was transformed, so we can recalculate the data from the image if (self.cacheSerializer) &#123; cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url); &#125; else &#123; cacheData = (imageWasTransformed ? nil : downloadedData); &#125; [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;&#125;);// SDImageCache- (void)storeImage:(nullable UIImage *)imageimageData:(nullable NSData *)imageDataforKey:(nullable NSString *)keytoDisk:(BOOL)toDiskcompletion:(nullable SDWebImageNoParamsBlock)completionBlock 三、SDWebImage架构组成 由上图可以看出，SDWebImage的整体架构分为如下5个功能模块 SDWebImageManager承上启下部分SDWebImageManager组合了图片下载和图片缓存，还可以查询图片url对应的缓存是否在内存还是在磁盘，以及手动调用缓存图片到内存和磁盘这里主要介绍SDWebImageOptions的含义123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying. * This flag disable this blacklisting. */// 默认情况下，当一个URL下载失败，该URL被列入黑名单，将不会继续尝试下载，此标志取消黑名单 SDWebImageRetryFailed = 1 &lt;&lt; 0, /** * By default, image downloads are started during UI interactions, this flags disable this feature, * leading to delayed download on UIScrollView deceleration for instance. */// 默认情况下，在UI交互式会下载图片，此标志取消这一功能，会延迟下载，当scrollview减速的时候继续下载// 下载监听的运行runloop时defaultmode SDWebImageLowPriority = 1 &lt;&lt; 1, // 低优先级 /** * This flag disables on-disk caching after the download finished, only cache in memory */// 禁止磁盘缓存，只用内存缓存图片 SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, /** * This flag enables progressive download, the image is displayed progressively during download as a browser would do. * By default, the image is only displayed once completely downloaded. */// 此标志允许渐进氏下载，就像浏览器中那样，下载过程中，图片逐步显示出来// 默认情况下，图像只会在下载完成显示 SDWebImageProgressiveDownload = 1 &lt;&lt; 3, /** * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. * * Use this flag only if you can't make your URLs static with embedded cache busting parameter. */// 即使图片被缓存，遵守http响应的缓存机制，如果需要，从远程刷新图片；磁盘缓存将由NSURLCache处理而不是// SDWebImage，这会对性能有轻微影响；此标志有助于处理同一个请求URL的图像发生变化；如果缓存的图片被刷新，会调用依稀competion，并传递最终的图片；仅在无法使用嵌入式参数确定图片URL时使用此标志 SDWebImageRefreshCached = 1 &lt;&lt; 4, // 刷新缓存 /** * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for * extra time in background to let the request finish. If the background task expires the operation will be cancelled. */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, // 后台下载 /** * Handles cookies stored in NSHTTPCookieStore by setting * NSMutableURLRequest.HTTPShouldHandleCookies = YES; */ SDWebImageHandleCookies = 1 &lt;&lt; 6, /** * Enable to allow untrusted SSL certificates. * Useful for testing purposes. Use with caution in production. */// 可以出于测试目的使用，在正式产品中慎用 SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, // 允许不信任的SSL证书 /** * By default, images are loaded in the order in which they were queued. This flag moves them to * the front of the queue. */ SDWebImageHighPriority = 1 &lt;&lt; 8, // 高优先级下载 /** * By default, placeholder images are loaded while the image is loading. This flag will delay the loading * of the placeholder image until after the image has finished loading. */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, /** * We usually don't call transformDownloadedImage delegate method on animated images, * as most transformation code would mangle it. * Use this flag to transform them anyway. */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, /** * By default, image is added to the imageView after download. But in some cases, we want to * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance) * Use this flag if you want to manually set the image in the completion when success */ SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11, /** * By default, images are decoded respecting their original size. On iOS, this flag will scale down the * images to a size compatible with the constrained memory of devices. * If `SDWebImageProgressiveDownload` flag is set the scale down is deactivated. */ SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12, /** * By default, we do not query disk data when the image is cached in memory. This mask can force to query disk data at the same time. * This flag is recommend to be used with `SDWebImageQueryDiskSync` to ensure the image is loaded in the same runloop. */ SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13, /** * By default, we query the memory cache synchronously, disk cache asynchronously. This mask can force to query disk cache synchronously to ensure that image is loaded in the same runloop. * This flag can avoid flashing during cell reuse if you disable memory cache or in some other cases. */ SDWebImageQueryDiskSync = 1 &lt;&lt; 14, /** * By default, when the cache missed, the image is download from the network. This flag can prevent network to load from cache only. */ SDWebImageFromCacheOnly = 1 &lt;&lt; 15, /** * By default, when you use `SDWebImageTransition` to do some view transition after the image load finished, this transition is only applied for image download from the network. This mask can force to apply view transition for memory and disk cache as well. */ SDWebImageForceTransition = 1 &lt;&lt; 16&#125;; 图片缓存模块图片缓存包括内存缓存和磁盘缓存，总共就两个类：SDImageCacheConfig缓存配置类和SDImageCache缓存核心类。 先看SDImageCacheConfig类的初始化方法，里面主要是一些配置信息 1234567891011121314- (instancetype)init &#123; if (self = [super init]) &#123; _shouldDecompressImages = YES; // 解压缩下载和缓存的图像可以提高性能，但会占用大量内存。默认为YES。 如果由于过多的内存消耗而遇到崩溃，请将此项设置为NO。 _shouldDisableiCloud = YES; // 禁止iCloud备份，默认为YES _shouldCacheImagesInMemory = YES; // 是否使用内存缓存，默认为YES，禁用内存缓存时，也会禁用弱内存缓存。 _shouldUseWeakMemoryCache = YES; // 弱内存缓存，默认为YES _diskCacheReadingOptions = 0; // 从磁盘读取缓存时的读取选项。 默认为0，可以将其设置为`NSDataReadingMappedIfSafe`以提高性能。 _diskCacheWritingOptions = NSDataWritingAtomic; // 将缓存写入磁盘时的写入选项。默认为`NSDataWritingAtomic`。 可以将其设置为“NSDataWritingWithoutOverwriting”以防止覆盖现有文件。 _maxCacheAge = kDefaultCacheMaxCacheAge; // 图片保留在缓存中的最长时间（以秒为单位），默认为7天。 _maxCacheSize = 0; // 缓存的最大大小，以字节为单位，默认为0。 _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate; // 清除磁盘缓存时将检查清除缓存的属性，默认为修改日期 &#125; return self;&#125; SDImageCache类2.1 SDMemoryCache继承NSCache，专门处理内存缓存。，NSCache是苹果官方提供的缓存类，和NSMutableDictionary类似，但是又有区别，区别如下：NSCache是线程安全的；NSCache的Key只是对对象进行强引用，不是拷贝(NSDictionary对key会进行拷贝)；最主要是SDMemoryCache里面有一个NSMapTable类型的的weakCache属性进行二级缓存，他的主要作用是当内存警告，缓存被清除时， 但是，图像实例可以由其他实例保留例如imageViews而存活，在这种情况下，我们可以同步弱缓存，而不需要从磁盘缓存加载。NSMapTable: more than an NSDictionary for weak pointers。weakCache的设值和取值，使用了GCD中的信号量进行加锁保证线程安全，self.weakCacheLock = dispatch_semaphore_create(1);。监听系统内存警告通知UIApplicationDidReceiveMemoryWarningNotification，并且通过调用[super removeAllObjects];移除缓存，但是保留了弱缓存weakCache。设置内存缓存的方法是：[self.memCache setObject:image forKey:key cost:cost];，其中key是图片的url，object是UIImage类型对象，cost等于image.size.height * image.size.width * image.scale * image.scale。2.2 磁盘缓存，缓存路径是：~/Library/Caches/default/com.hackemist.SDWebImageCache.default。图片缓存名：url(md5) + .扩展。图片存储到磁盘和查询都是在串行队列中进行，保证线程安全//_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);监听了UIApplicationWillTerminateNotification和UIApplicationDidEnterBackgroundNotification事件进行磁盘清理，清理操作也是在ioQueue中进行异步清理，保证线程安全。清理磁盘缓存逻辑如下：第一步：清除已经超多最大缓存时间（默认一周）的缓存文件；第二步：保存缓存文件大小；第三步：判断设置的缓存大小，进行第二轮清除。具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 清除磁盘缓存的核心方法- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123; dispatch_async(self.ioQueue, ^&#123; // 磁盘缓存路径 NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; // Compute content date key to be used for tests NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey; switch (self.config.diskCacheExpireType) &#123; case SDImageCacheConfigExpireTypeAccessDate: cacheContentDateKey = NSURLContentAccessDateKey; break; case SDImageCacheConfigExpireTypeModificationDate: cacheContentDateKey = NSURLContentModificationDateKey; break; default: break; &#125; // NSURLIsDirectoryKey:拿到目录的key；vcacheContentDateKey:最后修改时间的key；vNSURLTotalFileAllocatedSizeKey：文件总大小key NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey]; // This enumerator prefetches useful properties for our cache files. // 枚举器遍历磁盘缓存路径，NSDirectoryEnumerationSkipsHiddenFiles：不遍历隐藏路径 // 迭代器设计模式 NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; // 截止日期（返回最大时间之前的日期），7天之前的时间 NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; NSUInteger currentCacheSize = 0; // Enumerate all of the files in the cache directory. This loop has two purposes: // // 1. Removing files that are older than the expiration date. // 2. Storing file attributes for the size-based cleanup pass. NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; for (NSURL *fileURL in fileEnumerator) &#123; NSError *error; NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // Skip directories and errors. if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; continue; &#125; // Remove files that are older than the expiration date; // 拿到最后的修改日期 NSDate *modifiedDate = resourceValues[cacheContentDateKey]; // 过期的存到数组里面 if ([[modifiedDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; [urlsToDelete addObject:fileURL]; continue; &#125; // 未过期的添加到cacheFiles里面 // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles[fileURL] = resourceValues; &#125; for (NSURL *fileURL in urlsToDelete) &#123; [self.fileManager removeItemAtURL:fileURL error:nil]; &#125; // If our remaining disk cache exceeds a configured maximum size, perform a second // size-based cleanup pass. We delete the oldest files first. // 判断是否超出磁盘缓存上限，默认是没有指定的 if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123; // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // Sort the remaining cache files by their last modification time or last access time (oldest first). NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[cacheContentDateKey] compare:obj2[cacheContentDateKey]]; &#125;]; // Delete files until we fall below our desired cache size. for (NSURL *fileURL in sortedFiles) &#123; if ([self.fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; app进入后台进行清理有向系统申请后台存活时间，具体代码如下：12345678910111213141516171819- (void)backgroundDeleteOldFiles &#123; Class UIApplicationClass = NSClassFromString(@"UIApplication"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123; // Clean up any unfinished task business by marking where you // stopped or ending the task outright. [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;]; // Start the long-running task and return immediately. [self deleteOldFilesWithCompletionBlock:^&#123; [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;];&#125; 图片下载模块总共就两个类：SDWebImageDownloader和SDWebImageDownloaderOperation每个下载任务的超时时长15s，_downloadTimeout = 15.0;下载的最大并发数是6个，_downloadQueue.maxConcurrentOperationCount = 6;；这里说下串行队列和并发队列的区别：串行队列（Serial Queue）指队列中同一时间只能执行一个任务，当前任务执行完后才能执行下一个任务，在串行队列中只有一个线程。并发队列（Concurrent Queue）允许多个任务在同一个时间同时进行，在并发队列中有多个线程。串行队列的任务一定是按开始的顺序结束，而并发队列的任务并不一定会按照开始的顺序而结束。这里最大并发数设置为6表示队列中最多只能有6个图片下载任务同时进行。SDWebImageDownloader类的核心思想逻辑是以需要下载图片url作为key来创建一个NSOperation，用URLOperations保存，这么做的目的是避免创建重复的下载；创建完成后的operation就会被添加到downloadQueue中开始下载任务：12345678910111213141516171819202122232425262728293031323334353637383940414243- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; LOCK(self.operationsLock); NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *operation = [self.URLOperations objectForKey:url]; // There is a case that the operation may be marked as finished, but not been removed from `self.URLOperations`. if (!operation || operation.isFinished) &#123; operation = [self createDownloaderOperationWithUrl:url options:options]; __weak typeof(self) wself = self; operation.completionBlock = ^&#123; __strong typeof(wself) sself = wself; if (!sself) &#123; return; &#125; LOCK(sself.operationsLock); [sself.URLOperations removeObjectForKey:url]; UNLOCK(sself.operationsLock); &#125;; [self.URLOperations setObject:operation forKey:url]; // Add operation to operation queue only after all configuration done according to Apple's doc. // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock. [self.downloadQueue addOperation:operation]; &#125; UNLOCK(self.operationsLock); id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; SDWebImageDownloadToken *token = [SDWebImageDownloadToken new]; token.downloadOperation = operation; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; return token;&#125; SDWebImageDownloaderOperation就是具体进行下载图片操作的类，核心方法就是start方法里面使用创建一个NSURLSession进行下载操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899- (void)start &#123; @synchronized (self) &#123; if (self.isCancelled) &#123; self.finished = YES; [self reset]; return; &#125;#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@"UIApplication"); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123; __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123; __strong __typeof (wself) sself = wself; if (sself) &#123; [sself cancel]; [app endBackgroundTask:sself.backgroundTaskId]; sself.backgroundTaskId = UIBackgroundTaskInvalid; &#125; &#125;]; &#125;#endif NSURLSession *session = self.unownedSession; if (!session) &#123; NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfig.timeoutIntervalForRequest = 15; /** * Create the session for this task * We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate * method calls and completion handler calls. */ session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil]; self.ownedSession = session; &#125; if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123; // Grab the cached data for later check NSURLCache *URLCache = session.configuration.URLCache; if (!URLCache) &#123; URLCache = [NSURLCache sharedURLCache]; &#125; NSCachedURLResponse *cachedResponse; // NSURLCache's `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483 @synchronized (URLCache) &#123; cachedResponse = [URLCache cachedResponseForRequest:self.request]; &#125; if (cachedResponse) &#123; self.cachedData = cachedResponse.data; &#125; &#125; self.dataTask = [session dataTaskWithRequest:self.request]; self.executing = YES; &#125; if (self.dataTask) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wunguarded-availability" if ([self.dataTask respondsToSelector:@selector(setPriority:)]) &#123; if (self.options &amp; SDWebImageDownloaderHighPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityHigh; &#125; else if (self.options &amp; SDWebImageDownloaderLowPriority) &#123; self.dataTask.priority = NSURLSessionTaskPriorityLow; &#125; &#125;#pragma clang diagnostic pop [self.dataTask resume]; for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123; progressBlock(0, NSURLResponseUnknownLength, self.request.URL); &#125; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_main_queue(), ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf]; &#125;); &#125; else &#123; [self callCompletionBlocksWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@&#123;NSLocalizedDescriptionKey : @"Task can't be initialized"&#125;]]; [self done]; return; &#125;#if SD_UIKIT Class UIApplicationClass = NSClassFromString(@"UIApplication"); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123; UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)]; [app endBackgroundTask:self.backgroundTaskId]; self.backgroundTaskId = UIBackgroundTaskInvalid; &#125;#endif&#125; 图片编解码模块这一块内容自己也还是没有完全弄懂，包括decode，decompress，encode，目前还在学习中。核心方法:强制解压图片(此过程在子线程中进行)，谈谈 iOS 中图片的解压缩1234567891011121314151617181920212223242526272829303132333435363738394041424344- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123; if (![[self class] shouldDecodeImage:image]) &#123; return image; &#125; // autorelease the bitmap context and all vars to help system to free memory when there are memory warning. // on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory]; @autoreleasepool&#123; CGImageRef imageRef = image.CGImage; // device color space CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB(); BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef); // iOS display alpha info (BRGA8888/BGRX8888) CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); // kCGImageAlphaNone is not supported in CGBitmapContextCreate. // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast // to create bitmap graphics contexts without alpha info. CGContextRef context = CGBitmapContextCreate(NULL, width, height, kBitsPerComponent, 0, colorspaceRef, bitmapInfo); if (context == NULL) &#123; return image; &#125; // Draw the image into the context and retrieve the new bitmap image without alpha CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context); UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation]; CGContextRelease(context); CGImageRelease(imageRefWithoutAlpha); return imageWithoutAlpha; &#125;&#125; UIkit扩展模块这里主要是各个UI控件设置网络图片的便捷方法，使用category刚好满足需求，也是用户接触最多的。比如下面的设置方法：123[cell.customImageView sd_setImageWithURL:[NSURL URLWithString:self.objects[indexPath.row]]placeholderImage:placeholderImageoptions:indexPath.row == 0 ? SDWebImageRefreshCached : 0]; 总之，学完之后，很多编程思想可以借鉴这些优秀的开源库，并且在自己的项目中实践。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发遇坑总结]]></title>
    <url>%2F2018%2F05%2F16%2F2018-05-16%2F</url>
    <content type="text"><![CDATA[由使用Associated Objects不当导致app闪退总结前段时间项目新增一个需求需要接入一个第三方的sdk，我们需要使用这个第三方sdk提供的一个model类MMdata数据，具体我们的需要实现的是：在sdk进行网络请求回来的数据回调中[MMdata]数组通过OC中runtime获取MMdata.m的一些私有属性及其变量的值然后将这些数据上传到我们自己服务器审核这些数据，服务器返回[MMdata]数组中哪些可用哪些不可用，然后我们对些可用的数据添加时间戳及其它属性以来满足我们那业务的需求。刚做这个的需求想到了好几个方案：一是使用继承，写一个继承MMdata的子类并且添加自己需要的属性值；二是重写一个本地类将MateriaMeta的数据全部给重写过来，在添加自己所想添加的；三是使用对象关联技术使用分类添加需要扩展的属性。经过一段小组之间的讨论，最后决定使用第三种方案。方法一二相比，明显第二种方法解耦合了，我们新建model类不依赖于SDK第三方了，而且在赋值的时候继承对于它父类的私有属性不好处理你还是得写一次，所以方法二优于方法一。然后比较二三方法，方法三更具有优势，因为只需要在我们服务器审核成功之后对MMdata的分类MMdata+Extension 的属性赋值即可。 我的写法如下：1234567891011121314MMdata+Extension.h/*@property (nonatomic, assign) NSTimeInterval timestamps;*/MMdata+Extension.m- (NSTimeInterval)timestamps &#123; return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setTimestamps:(NSTimeInterval)timestamps &#123; objc_setAssociatedObject(self, @selector(timestamps), [NSNumber numberWithDouble:timestamps], OBJC_ASSOCIATION_ASSIGN);&#125; 最后奔溃就在第九行，在使用timestamps的时候报了野指针错误，然而这个问题在上线前测试这边都没有出现过问题，上线后大量用户反馈闪退，以及通过后台闪退数据的抓取到就是这里的问题 事后分析原因，可能是在setTimestamps:方法中我使用的是OBJC_ASSOCIATION_ASSIGN修饰导致的。首先，我查看了runtime的官方文档对对象关联的修饰符介绍。1234567891011121314151617/* Associative References *//*** Policies related to associative references.* These are options to objc_setAssociatedObject()*/typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object.* The association is made atomically. */OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied.* The association is made atomically. */&#125;; 错误信息：1-[CFNumber retain]: message sent to deallocated instance 0x604001620360 通过Xcode的lldb调试工具watchpoint后面找出原因是就是使用OBJC_ASSOCIATION_ASSIGN修饰的原因：timestramps是一个弱引用，所以当出了这个括号timestramps所指向的对象(也就是[NSNumber numberWithDouble:timestamps])就被释放了，然而timestramps仍然有值，还是保存了原对象的地址。所以当使用objc_getAssociatedObject去取值的时候就会Crash。所以解决方案就是将OBJC_ASSOCIATION_ASSIGN改为OBJC_ASSOCIATION_RETAIN_NONATOMIC。 通过进一步了解到，在分类使用对象关联添加的属性(property)，他不是存放在类对象的内存中，因为在运行期间对象的内存布局已经确定。它存在于一个AccociationManager对象的AssociationHashMap中；AssociationHashMap的key是关联类对象的地址，value是ObjectAssociationMap；ObjectAssociationMap的key是传递进来的 const void * _Nonnull key，value 是ObjcAssociation包括关联策略policy和关联对象value。 NSInteger 和 NSUInteger 进行比较看下面的比较，你认为会输出多少？1234567NSInteger i = -1;NSArray *arr = @[];if (i &lt; arr.count) &#123;NSLog(@"&lt;");&#125; else &#123;NSLog(@"&gt;");&#125; 结果是控制台打印&gt;，你可能会想一看不对呀，i==-1.arr.count==0,不应该是输出&lt;么；带我细细讲来，这个问题我们小组好几个人都踩过这个坑，一般是在if条件判断数组个数的时候，或者for循环条件判断的时候。比如上面这种形式，结果走了else语句。 我们知道两个不同类型的比较，会进行隐式转换，即低精度会向高精度的数字转换，然后再进行比较，那上面代码的例子来说，if比较的NSInteger类型与NSUInteger类型，就是NSInteger类型会转化为NSUInteger类型，然后再比较。所以有符号整型-1与无符号整型0的比较，会先将有符号的整形-1转化为无符号的-1。那有符号整型-1在计算机中是通过二进制补码的形式进行存储的，且最前面一位是符号为0正1负，补码=原码取反加一。以64位iPhoneX为例，-1的存储图位，有符号的-1存储在机器上时64个1；所当变成无符号的时候，其值就是2的64次方=18446744073709551615。1234位数 63 62 62 …… 2 1 0原码 1 0 0 0 0 0 1反码 1 1 1 1 1 1 0补码 1 1 1 1 1 1 1 大家可以在Xcode断点调试验证下。这里也说明了swift的安全严谨性，他在编译阶段就能够让你察觉这个错误。]]></content>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP读书笔记]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10%2F</url>
    <content type="text"><![CDATA[过完年，整个人的状态都放松了，可能是假期综合症，回顾去年，整个人的提升没有达到自己的预期，于是乎在网上买了几本技术书籍，要充实一下自己。今年还给自己定了一个新的小目标就是准备年底考研，考北京理工大学非全日制的工程管理硕士，一方面是学习项目管理方面一些知识，另一方面是提升自己的学历。最初的动力来一个是自于自己的内心不甘，不甘14-15年那次考研的失利；另一方面来自于家庭父母乃至家族的期望，于是必须让自己充实起来，趁着年轻多学点知识，特别是程序员这一行技术本来就日新月异，要在职场中具备竞争力就必须不断的学习提升自己。最终的目标当然是为了以后升职加薪，让父母和自己过上好的生活。为此我在这立一个flag：减少自己的休闲玩乐时间，为考研背水一战，坚持就是胜利。以下是自己花两天时间使用MinNode整理知识总结，供以后查阅翻看： 看到https，我就想说下之前我们公司项目从http迁移到https所要的工作和遇到的坑： 迁移到https，我们移动端的工作：只是将项目的域名（BaseURL）由http改为https，证书购买和配置工作都是有服务端和运维的同事完成的，我们公司使用的在阿里云购买的云盾证书服务； https的ssl没有续费导致的证书过期进而导致所有的借口访问失败，提示超时 https之前的http阶段有些安卓机的webview页面出现广告（很大一部分原因是宽带运营商的流量劫持），最后全部解决依靠https iOS中的info.plist中的App Transport Security Settings下的Allow Arbitrary Loads得改为NO]]></content>
  </entry>
  <entry>
    <title><![CDATA[React Native 集成到现有项目有感]]></title>
    <url>%2F2018%2F01%2F30%2F2018-01-30%2F</url>
    <content type="text"><![CDATA[公司项目最开始使用Objective-C构建的，在2016年开始2.0版本的开发，那个时候老大就要求我们研究下React Native，希望一些新的功能模块使用RN来实现，那时React Native还没开始普及（Android的RN版本好像还没有出），坑也比较多，对于一些动画支持不太好，研究一段时间并且经过评估后放弃了这种技术选型；但是使用原生实现又面临Objective-C和Swift的选择，尽管那个时候开发时间紧而且我也是自己在空闲时间学习过swift，并没有在实际项目中运用过，但我那时力推使用Swift语言并，且最终使用Swift开发新的功能模块，到目前为止项目中除了一个模块和一些底层的封装库还是Objective-C，其余代码都已经全部使用Swift实现。回归正题，经过一年的沉淀，RN如今已经可以比较成熟，所以我最近在研究将项目中某些功能模块使用React Native来写的可能性，特别是那些使用Objective-C写的老模块，然而如今遇到一个棘手问题，这个旧模块（名叫成长档案），是可以无限上拉加载的，于是会出现性能问题，以及快速滑动来不及渲染而出现白屏得情况。目前还没有找到有效的解决方案，问题如下图所示：这个长列表我是用的是Flatlist组件实现，快速滑动会出现这种空白情况，这种情况我在RNTester的Demo中也有出现. 由于没有item复用，性能也提升不上来了，官方建议我们使用原生实现这种长列表，而我查看RN实现的案例app中，包括F8、Airbnb、Instagram，尽管也有列表页面，但是都是几屏数据，并没有几百来条数据需要渲染。 项目运行地址在 Weather-ReactNative项目的develop分支 如果你有解决方案，欢迎探讨]]></content>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2017年终总结]]></title>
    <url>%2F2018%2F01%2F09%2F2018-01-09%2F</url>
    <content type="text"><![CDATA[又是一年花开花落，2017年俨然已经过去一周多了，此时的我才来写这年终的总结，早在12月份就想着一年快结束了得写年终总结了，但是我就是有惰性，拖延症，硬是要拖到现在才来写！ 步入的18年是我整整工作3周年的日子，从还未毕业就工作的毛头小子到现在整整三年啦的，整体感觉自己成熟了不少，同时话语也少了些许，工作少了一些激情，多了一份从容，坚持。自己从16年初在简书开始坚持写文章，写博客，只为记录自己的成长；现在回过头去看来发现自己的成长有些许慢，和一些同龄人相比自己感觉到很大的差距，有时看到别人成长的如此迅速，心里甚是羞愧，心还想着自己也该觉醒了，该起来奋斗了，不进则退！三年来自己一些习惯有的已经丢弃，比如写日记，周记；有的则还在坚持，比如跑步，游泳，健身锻炼还在坚持着每周至少三次的频率；有的则在退步，16年我写了16篇文章，17年则只写了10篇文章。 回顾2017年：喜悦： 年初找到了自己的另一半，前几天刚好是一周年纪念日，两个人很合得来，三观一致，也喜欢运动，经常一起去健身，去滑雪，爬山； 贷款买房，首付款父母资助的（很惭愧，工作两年都没有存一个首付款）；刚工作时感觉房子可买可不买，以后老了就在老家里的小三层住着也挺好；在北京工作久了，搬家好几次，真的没有归属感，最重要是以后的孩子的教育问题等等，还有就是是受到16年房价的上涨刺激，感觉自己在不上车就来不及了，于是在就在家里的资助下在老家省会贷款买了一套；说实话，感觉压力还挺大的，每月的工资需要支付，近7千的贷款，2千多房租，还有生活费。一个月下来工资所剩不多。因为限购限贷，上半年一直在倒腾这事。 使用GitHub Pages + Hexo搭建了自己的个人站点，并且将简书的文章迁移过来；对于个人博客的搭建，看个人的喜好，毕竟现在有好多的平台供大家写博客； 年末的最后一周学习了ReactNative，并且写了个小小的天气app，算是完成了年初建立的目标；RN开发并没有我想象中的难，我花了小小的一周就开发了一个简单的天气app，我计划18年能不能将公司的项目里面一些新需求使用这个技术来实现 看了不少书籍，包括微信读书和京东买的书籍，有个遗憾之处，没有写读书笔记；我一直坚持这个观点，理科生在提升自己的技术同时，也需要适当的陶冶一下情操，看一些优秀的书籍来充实自己，一个最明显的实用之处就是和女生的交流多了一个可以沟通的话题。 工作能力有所提升，主要体现在团队的合作，开发的效率都有所提升，处理问题的能力。公司的开发人员越来越多，据好未来官方通报是将近2000的技术人员，一个明显的感受就是我们部门团队人员的增加，移动组由年初的6人达到了8人。 失落 公司年中的职位晋升落选，自己能力还有欠缺吧； 技术成长的速度没有达到自己的期待； 没有参加公司举办的小程序大赛和创新大赛，自己还是缺乏一定的产品思维见解能力，这方面需要不断的学习和提升； 父母正在一天一天的变老，身体的毛病也在显现，而我却没法在身边照顾他们。 展望2018坚持 坚持将RN写的天气这个app添加许多的功能，并且将学习分享出来，将RN这门技术彻底掌握，并且争取运用到公司新功能模块的开发中； 坚持健身锻炼，身体是革命的本钱； 坚持写作，每月一篇，可以是技术文章，也可以是读书笔记； 坚持读书每周读完一本书籍； 坚持学习的能力，比如学习一下python； 努力赚钱。 体验 体验不一样的生活，比如多参加开源活动，多出去认识一些人； 召集朋友偶尔聚一聚； 旅行，办了一张京津冀的旅游卡，多去外面看一看； 工作，当在一个公司到达了一定的瓶颈，可以考虑换一个环境。]]></content>
      <tags>
        <tag>个人总结</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用ReactNative优雅快速开发一个属于自己的app]]></title>
    <url>%2F2017%2F12%2F28%2F2017-12-28%2F</url>
    <content type="text"><![CDATA[先看整体app的效果，源码GitHub代码地址，欢迎大家进行star和一起探讨。 本人代码的开发环境信息：12345678Mac电脑系统：Mac OS X 10.13.2IDE：Sublime Text，version 3.0，Build 3143node版本：v9.3.0npm版本：5.6.0yarn版本: 1.3.2(npm和yarn使用其中一个就行)react-native版本: 0.51.0Xcode: Version 9.2 (9C40b)Android Studio 3.0.1 工具篇-工欲善其事，必先利其器我选择的代码编辑器是Sublime Text（可能需要翻墙才能访问下载，我在百度网盘分享一个链接：Sublime Text 3，密码：bmjs），选择他来开发React Native应用的主要原因是他是免费的。但是想要高效使用Sublime开发就必须使用Sublime的插件包管理器Package Control下载几个高效开发的插件：JSX(ES6)语法高亮插件Babel、JSX代码格式化插件JsFormat、JSX语法检测插件ESLint。目前自己代码开发用到这三个就足够了。 我发现另一个开发工具Expo Snack很强大，直接在浏览器上写RN代码，然后实时查看效果，迅速提升开发效率，还可将app发布到Expo上面进行查看，比如react-navigation的学习demo NavigationPlayground，新手可以尝试使用这个工具进行开发。 安装包管理器（Package Control）Tools -&gt; Command Palette… -&gt; 输入：Install ，然后鼠标单击Package Control选项，Sublime编辑器的左下角应该会有文字提示正在下载。查看是否下载成功：Sublime Text -&gt; Preferences 最下面有Package Control 安装JSX语法高亮插件：Babel先看效果：如今，React Native使用JSX（ES6）语法开发，sublime是没法高亮的，从上图左半部分的右下角和右半部分的右下角的区别在于可以看出默认JavaScript和Javascript(Babel)，这正是js和jsx语法的区别，但是默认是没有Babel语言选项的，我们需要Package Control进行下载。安装步骤：快捷键Shift+Command+P -&gt; 输入：Install Package，回车 -&gt; 输入：Babel，回车。查看是否下载成功：Sublime Text -&gt; Preferences -&gt; Package Settings 里面是否有Babel。切换语法为Babel，点击Sublime右下角语言这里切换为Babel，此源文件就可以高亮了。 我遇到一个问题是：当我关闭了项目，下次再次打开，js文件的默认语言还是JavaScript，想要高亮还得在重复上一步操作：切换语法为Babel。如果哪位有一劳永逸的设置方法，请告知下！ 安装代码格式化插件：JsFormat安装、查看的步骤和2一样，使用Package Control搜索JsFormat。最为主要的是需要其他配置：首先，代码格式化快捷键ctrl+option+f，为了防止与其他插件快捷键冲突，我们最好在Key Bindings - User中添加如下json1&#123; "keys": ["ctrl+alt+f"], "command": "js_format", "context": [&#123;"key": "selector", "operator": "equal", "operand": "source.js,source.json"&#125;] &#125; 其次，我们需要设置代码格式化对JSX的支持，如上图JsFormat设置 我们打开Settings-&gt;User ，并且添加如下json： 12345&#123; "e4x": true, // 支持jsx "format_on_save": false, // 保存自动代码格式化，默认也为false，可以不加 "brace_style": "collapse-preserve-inline", // &#123;&#125; 不换行，加与不加的效果自己体验&#125; 当我设置了&quot;format_on_save&quot;: true，我发现使用快捷键自动保存代码，触发代码格式化时有的代码会出现错乱，而且只是在ListView这部分会出现这样的情况，如下gif所示，如果哪位解决这个问题我们可以探讨下。所以当我需要代码格式化时，我一般是选中需要代码格式化的部分进行代码格式化。 安装语法检测插件ESLint4.1 安装ESLint、以及ESLint插件我选择的是局部安装（安装在当前项目目录/node_modules/目录下），（如果全局安装则都使用全局安装，安装在/usr/local/lib/node_modules目录下），在项目根目录下依次，终端依次执行以下命令：1234567$ npm install eslint --save-dev$ npm install eslint-plugin-react --save-dev # ESLint支持React语义JSX的插件$ npm install eslint-plugin-react-native # React Native 的插件$ npm install babel-eslint #支持ES6语法的插件 安装的时候注意是否出现 UNMET PEER DEPENDENCY 字段，出现了则代表安装失败，那么可以尝试全局安装。4.2 配置.eslintrc文件切换到项目根目录(即包含packge.json的目录下)，执行eslint --init之后在项目根目录生成了一个.eslintrc.json文件，并且配置如下：12345678910111213141516171819202122232425262728293031&#123; "env": &#123; "es6": true, "node": true, "react-native/react-native": true &#125;, "extends": ["eslint:recommended", "plugin:react/recommended","plugin:react-native/all"], "plugins": [ "react", "react-native" ], "parser": "babel-eslint", "parserOptions": &#123; "ecmaVersion": 6, "ecmaFeatures": &#123; "jsx": true &#125; &#125;, "rules": &#123; // 规则，包括React Native语法的规则 "class-methods-use-this": 0, "react-native/no-color-literals": 0, "react-native/no-unused-styles": 0, "react-native/no-inline-styles": 0, "react-native/split-platform-components": 2, "no-unused-vars": 0, "no-use-before-define": 0, "no-console": 0, "react/prop-types": 0, "react/no-direct-mutation-state": 0 &#125;&#125; 想要更详细的配置可以查看下官网的Configuring ESLint。4.3 安装Sublime插件SublimeLinter、SublimeLinter-contrib-eslint使用package control进行安装，然后配置setting-user文件如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; "user": &#123; "debug": true, "delay": 0.25, "error_color": "D02000", "gutter_theme": "Packages/SublimeLinter/gutter-themes/Default/Default.gutter-theme", "gutter_theme_excludes": [], "lint_mode": "background", "linters": &#123; "eslint": &#123; "@disable": false, "args": [], "excludes": [] &#125;, "jsxhint": &#123; "@disable": false, "args": [], "excludes": [] &#125; &#125;, "mark_style": "outline", "no_column_highlights_line": false, "passive_warnings": false, "paths": &#123; "linux": [], "osx": [], "windows": [] &#125;, "python_paths": &#123; "linux": [], "osx": [], "windows": [] &#125;, "rc_search_limit": 3, "shell_timeout": 10, "show_errors_on_save": false, "show_marks_in_minimap": true, "syntax_map": &#123; "html (django)": "html", "html (rails)": "html", "html 5": "html", "javascript (babel)": "javascript", "magicpython": "python", "php": "html", "python django": "python", "pythonimproved": "python" &#125;, "tooltip_fontsize": "1rem", "tooltip_theme": "Packages/SublimeLinter/tooltip-themes/Default/Default.tooltip-theme", "tooltip_theme_excludes": [], "tooltips": false, "use_current_shell_path": false, "warning_color": "DDB700", "wrap_find": true &#125;&#125; 效果如下： 代码篇悦月天气这个app比较简单（GitHub代码地址），主要有两部分：城市天气展示界面，选择城市界面。首页的天气预报的接口使用的是和风天气免费的每天1000次访问的API，城市列表数据使用的郭霖的第一行代码的接口。下面是一套RN代码分别在iPhone6模拟器和android模拟器的效果，代码复用率几乎为100%。 开发这个app花费我总共一周的时间，包括去学习RN最基本的 JSX语法、组件、state状态以及props，到现在全部完成整个app，到目前为止，我也只能算是懂一点皮毛，至于要更加深入的理解、使用，则需要更多的实践和学习，所以这代码部分我更多的是以一个初学者的身份来怎么快速进行编码和解决问题。至于学习教程我建议使用React Native官网的资料，而不是React Native 中文网，但是这个就需要一点英语基础了，遇到实在不懂的，完全可以使用翻译工具解决，看原始英文文档的好处是可以接触最新的技术，同时提升自己的英语水平。比如下面要提及的比如create-react-native-app、Expo等等技术。 创建项目：create-react-native-app我使用的是终端命令：create-react-native-app DailyWeather而不是react-native init DailyWeather来创建的项目。这二者最大的区别就是，前者没有嵌入式，直接npm start或者yarn start就能运行项目，再结合Expo app就能在模拟器实时查看运行效果，没有ios和android这两个文件目录，一个纯js项目，不能通过Xcode或者Android Studio开发工具打开项目进行配置。由于我这个app的icon图标和启动图片是使用原生配置，所以需要执行npm run eject或yarn run eject命令，生成这两个ios和android目录，然后通过配置Xcode和Android Studio来配置icon图标和启动页。 运行项目在项目目录执行yarn run eject之前（也就是有ios和android两个工程项目目录之前），我是直接执行yarn start启动一个开发服务器，然后在模拟器或者手机上使用Expo app 打开悦月天气app进行开发调试；之后我就直接通过Xcode和Android Studio分别打开项目然后运行在模拟器上，运行之前得先将AppDelegate.m的第21行代码jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil];改为jsCodeLocation = [NSURL URLWithString:@&quot;http://127.0.0.1:8081/index.bundle?platform=ios&amp;dev=true&quot;];否则运行将报错： 首页代码编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187class HomeScreen extends Component &lt; &#123;&#125; &gt; &#123; //组件的构造方法，在组建创建的时候调用 constructor(props) &#123; super(props); var ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;); this.state = &#123; isLoading: true, quiltyColor: true, refreshing: false, dataSource: ds, suggegstions: &#123;&#125;, // 代表一个空json,生活建议 aqi: &#123;&#125;, // aqi basic: &#123;&#125;, title: '海淀' // 默认获取海淀区的天气 &#125;; &#125; // 页面的渲染 render() &#123; if (this.state.isLoading) &#123; return ( &lt;View style=&#123;&#123;flex: 1, justifyContent: 'center', alignItems: 'center'&#125;&#125;&gt; &lt;ActivityIndicator/&gt; &lt;/View&gt; ) &#125; return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &#123;/*北京图*/&#125; &lt;ImageBackground source=&#123;&#123;uri: 'http://cn.bing.com/az/hprichbg/rb/BarHarborCave_ROW9345444229_1920x1080.jpg'&#125;&#125; style=&#123;&#123;width: screenWidth, height: screenHeight&#125;&#125;&gt; &lt;ScrollView style = &#123;&#123;flex: 1&#125;&#125; refreshControl=&#123; &lt;RefreshControl refreshing=&#123;this.state.refreshing&#125; onRefresh=&#123;this._onRefresh.bind(this)&#125;/&gt; &#125;&gt; &#123;/*渲染头部信息*/&#125; &#123;this.reanderHeader()&#125; &#123;/*渲染天气预报列表*/&#125; &#123;this.reanderForecast()&#125; &#123;/*渲染天气质量*/&#125; &#123;this.renderAirquilty()&#125; &#123;/*渲染生活指数*/&#125; &#123;this.renderSuggestion()&#125; &lt;/ScrollView&gt; &lt;/ImageBackground&gt; &lt;/View&gt; ); &#125; _onRefresh() &#123; this.setupData(this.state.title); &#125; // 组件已经装载，绘制完毕调用 componentDidMount() &#123; console.log(screenWidth) console.log(screenHeight) this.setupData(this.state.title); &#125; // 组件即将卸载，组件要被从界面上移除时调用 componentWillUnmount() &#123; console.log('HomeScreen','componentWillUnmount') &#125; setupData(cityname) &#123; // cityid可以使用cityid 也可以使用 城市名，选择城市回调回来 let urlstr = 'http://guolin.tech/api/weather?key=41dd96cb90344217acbf5fe0813f16cd' + '&amp;cityid=' + cityname console.log(urlstr) fetch(urlstr) .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; console.log('success1', responseJson); console.log('success2', responseJson.HeWeather[0].daily_forecast); console.log('success3', responseJson.HeWeather[0].suggestion); this.setState(&#123; refreshing: false, isLoading: false, dataSource: this.state.dataSource.cloneWithRows(responseJson.HeWeather[0].daily_forecast), suggegstions: responseJson.HeWeather[0].suggestion, aqi: responseJson.HeWeather[0].aqi, title: responseJson.HeWeather[0].basic.city, des: responseJson.HeWeather[0].now.cond.txt, temp: responseJson.HeWeather[0].now.tmp, &#125;) &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125; reanderHeader() &#123; return ( &lt;View style=&#123;styles.header&#125;&gt; &lt;View style=&#123;&#123;flexDirection: 'row', alignItems: 'center' ,marginTop: 44, marginBottom: 10&#125;&#125;&gt; &lt;Text style=&#123;styles.headerTitle&#125;&gt;&#123;this.state.title&#125;&lt;/Text&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; this.props.navigation.navigate('City',&#123;name: this.state.title, currentLevel: 0, callBack: (data) =&gt; &#123; console.log(data) // weather_id this.setupData(data); &#125;&#125;)&#125;&gt; &lt;Image source=&#123;require('./address.png')&#125;/&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;Text style=&#123;styles.headerDes&#125;&gt;&#123;this.state.des&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.headerTepe&#125;&gt;&#123;this.state.temp&#125;℃&lt;/Text&gt; &lt;/View&gt; ); &#125; reanderForecast() &#123; return ( &lt;View style=&#123;styles.forecast&#125;&gt; &lt;Text style=&#123;&#123;color: 'white', fontSize: 20, marginBottom: 10&#125;&#125;&gt;预报&lt;/Text&gt; &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData) =&gt; ( &lt;View style=&#123;styles.listView&#125;&gt; &lt;Text style=&#123;&#123;color: 'white',flex: 1&#125;&#125;&gt;&#123;rowData.date&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123;color: 'white',flex: 1&#125;&#125;&gt;&#123;rowData.cond.txt_d&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123;color: 'white',flex: 1&#125;&#125;&gt;&#123;rowData.tmp.max&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123;color: 'white',flex: 1&#125;&#125;&gt;&#123;rowData.tmp.min&#125;&lt;/Text&gt; &lt;/View&gt; )&#125;/&gt; &lt;/View&gt; ); &#125; renderAirquilty() &#123; let &#123; aqi &#125; = this.state; return ( &lt;View&gt; &lt;View style=&#123;styles.suggestion&#125;&gt; &lt;View style=&#123;&#123;flexDirection: 'row',justifyContent: 'flex-start', alignItems: 'center',padding: 20&#125;&#125;&gt; &lt;Text style=&#123;&#123;color: 'white',fontSize: 20&#125;&#125;&gt;空气质量：&lt;/Text&gt; &lt;Text style=&#123;&#123;color: 'red',fontSize: 17&#125;&#125;&gt;&#123;aqi.city.qlty&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;&#123;flex: 1,flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, alignItems: 'center' &#125;&#125;&gt; &lt;Text style=&#123;styles.airQuiltyDes&#125;&gt;AQI指数&lt;/Text&gt; &lt;Text style=&#123;styles.airQuiltyValue&#125;&gt;&#123;aqi.city.aqi&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;&#123;flex: 1, alignItems: 'center' &#125;&#125;&gt; &lt;Text style=&#123;styles.airQuiltyDes&#125;&gt;PM2.5&lt;/Text&gt; &lt;Text style=&#123;styles.airQuiltyValue&#125;&gt;&#123;aqi.city.pm25&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;View style=&#123;&#123;flex: 1,flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1,alignItems: 'center' &#125;&#125;&gt; &lt;Text style=&#123;styles.airQuiltyDes&#125;&gt;PM10&lt;/Text&gt; &lt;Text style=&#123;styles.airQuiltyValue&#125;&gt;&#123;aqi.city.pm10&#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;&#123;flex: 1, alignItems: 'center' &#125;&#125;&gt; &lt;Text style=&#123;styles.airQuiltyDes&#125;&gt;O3指数&lt;/Text&gt; &lt;Text style=&#123;styles.airQuiltyValue&#125;&gt;&#123;aqi.city.o3&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ) &#125; renderSuggestion() &#123; let &#123; suggegstions &#125; = this.state; return ( &lt;View style=&#123;styles.suggestion&#125;&gt; &lt;Text style=&#123;&#123;color: 'white',fontSize: 20,marginBottom: 20,marginTop: 20,marginLeft: 20&#125;&#125;&gt;生活建议&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;空气质量：&#123;suggegstions.air.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;舒适度：&#123;suggegstions.comf.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;洗车：&#123;suggegstions.cw.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;穿衣：&#123;suggegstions.drsg.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;感冒：&#123;suggegstions.flu.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;运动：&#123;suggegstions.sport.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;旅游：&#123;suggegstions.trav.txt&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.suggestionDes&#125;&gt;紫外线：&#123;suggegstions.uv.txt&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 我们主要看render()方法，这个方法主要进行页面的渲染。说实话，刚开始使用Flexbox布局时还真别扭（使用iOS布局技术AutoLayout久了），最后按照使用Flexbox倒腾了几个 demo，也就慢慢会了基本布局。背景图使用的是ImageBackground组件，首页信息显示使用的是ScrollView组件，三天的预报使用的ListView组件，其他的就是其他组件嵌套布局起来的。这里遇到过的两个阻碍，一是页面背景原先使用Image组件，但是发现他不能够嵌套其他元素；其次就是页面路由，使用的react-navigation的StackNavigator，在这里花费了两天学习，包括他的 官方demo NavigationPlayground（得先下载Expo app进行扫面二维码打开）； 城市列表代码编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120class CityScreen extends React.Component &#123; static navigationOptions = (&#123;navigation&#125;) =&gt; (&#123; headerMode: 'float', gesturesEnabled: true, headerTitle: `$&#123;navigation.state.params.name&#125;`, headerLeft: ( &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; navigation.goBack(null) &#125;&#125;&gt; &lt;Image source=&#123;require('./moments_btn_back.png')&#125; style=&#123;&#123;marginLeft: 8&#125;&#125;/&gt; &lt;/TouchableOpacity&gt; ), headerStyle: &#123; backgroundColor: '#6666ff', &#125;, headerTintColor: 'white', headerTitleStyle: &#123; fontSize: 20 &#125; &#125;); constructor(props) &#123; super(props); this.state = &#123; loading: true, currentLevel: 0, // 0:province, 1:city, 2:county; provinces: [&#123;&#125;], provinceData: &#123;&#125;, cityData: &#123;&#125; &#125;; &#125; render() &#123; const &#123; navigation &#125; = this.props; const &#123; state, setParams, goBack &#125; = navigation; const &#123; params, currentLevel &#125; = state; if (this.state.loading) &#123; return (&lt;View style=&#123;&#123;flex: 1, justifyContent: 'center', alignItems: 'center'&#125;&#125;&gt; &lt;ActivityIndicator/&gt; &lt;/View&gt;) &#125; return ( &lt;FlatList style=&#123;&#123;backgroundColor: 'white'&#125;&#125; data=&#123;this.state.provinces&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &#123; return ( &lt;TouchableOpacity style=&#123;&#123;justifyContent: 'center', alignItems: 'center',height: 44&#125;&#125; onPress=&#123;() =&gt; &#123; setParams(&#123;name: item.name&#125;) let level = this.state.currentLevel if (this.state.currentLevel === 0) &#123; this.state.provinceData = item &#125; else if (this.state.currentLevel === 1) &#123; this.state.cityData = item &#125; if (this.state.currentLevel === 2) &#123; console.log("goBack") state.params.callBack(item.weather_id) // 回调 goBack(null) &#125; else &#123; this.state.currentLevel = level + 1 setParams(&#123;currentLevel: level + 1&#125;) console.log(this.state.currentLevel) // console.log(this.state.provinceData ) this.state.loading = true this.setupData(this.state.currentLevel) &#125; &#125;&#125;&gt; &lt;Text style=&#123;&#123; color: 'gray', fontSize: 20&#125;&#125; &gt;&#123;item.name&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; )&#125; &#125; ItemSeparatorComponent=&#123; () =&gt; &#123; return ( &lt;View style=&#123;&#123;height: 1, backgroundColor: '#eee'&#125;&#125;/&gt; //&lt;/View&gt; )&#125;&#125; keyExtractor=&#123; (item, index) =&gt; item.id &#125; /&gt; ) &#125; componentDidMount() &#123; this.setupData(0) &#125; setupData(level) &#123; var urlstr = '' if (level == 0) &#123; urlstr = 'http://guolin.tech/api/china' &#125; else if (level == 1) &#123; let provinceData = this.state.provinceData console.log(provinceData) urlstr = 'http://guolin.tech/api/china/' + `$&#123;provinceData.id&#125;` &#125; else if (level == 2) &#123; let provinceData = this.state.provinceData let cityData = this.state.cityData urlstr = 'http://guolin.tech/api/china/' + `$&#123;provinceData.id&#125;` + '/' + `$&#123;cityData.id&#125;` &#125; console.log(urlstr) fetch(urlstr) .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; console.log(responseJson) this.setState(&#123; loading: false, provinces: responseJson, currentLevel: level, &#125;) &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;); &#125;&#125; 列表我是用的是FlatList组件，这个页面遇到的阻碍有两个，一是点击item更换navigation的headertitle；二是最后的点击城市回调数据给首页同时更新首页数据。 总结你可能会说这个app很简单，的确他很简单（比如没有地图，没有数据持久化等等，未来说不定就有了），只是一个简单的界面展示。但是只有当你真正实践去开发一个属于你的app时，你会发现其实过程没有你想的简单；但是当你完成时，你就会感觉小有成就，特别是能够分享出去，让更多的人看到。前两天看到池建强老师的2018技术趋势预测，移动开发学点js也很不错。]]></content>
      <tags>
        <tag>ReactNative</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅快速的搭建iOS工程框架搭建的探讨]]></title>
    <url>%2F2017%2F12%2F18%2F2017-12-18%2F</url>
    <content type="text"><![CDATA[一个简洁优雅的iOS工程目录，能够帮助团队提升开发效率，同时也令自己进行心情愉悦的编码；反之，杂乱无章的目录则会使人心情烦躁，降低团队开发效率。 不知你是否也有同感？欢迎你在评论区写下的感受。 首先，我想说： 本文说的工程架构适用于纯代码开发的团队，也适用于使用Storyboard开发的团队； 本文适用于传统的Tabbar+NavigationBar搭建的app，也适用于其他非传统的app； 本文特别适用于让团队的新进成员了解项目的整体构架，并且进行快速开发 本文以公司的FCS app为例，界面如下：公司的项目属于Objective-C和Swift混编的项目，对于纯swift的项目和纯OC的项目，可能文件夹和类文需要自行修改，Xcode项目工程目录如下：正如上图所示，我将项目划分为9大部分，GitHub地址： Models：模型数据类，所有自定义的数据模型应该放在此处；Views：视图类，以功能模块还需要再建一层文件夹，所有自定义的功能模块的视图类都应该放在给自的文件夹下此处，，手动拖入的第三方UI控件除外，第三方的UI应该放入Vendor文件夹里；Controllers：控制器类，所有控制器类放在此文件夹里面，如果有BaseViewController、BaseNavigationController可以放在Base文件夹下（可以在此目录下新建的一个Base文件夹），同时相应功能模块的Storyboard也放在此目录下，Storyboard放在此处相比于放在View里面更加方便（我们项目最开始在Views目录下新建Storyboards文件夹来存放所有的Storyboard，这样的做法弊端是去相应的Storyboard和功能模块的VC太远，操作不便）；Resouces：资源文件夹，存放项目需要用到的音频、视频、图片（webP格式的图片或者内存比较大png只需要用到一份的背景图片）、字体、动画等等资源文件都放在此处；Util，一些工具类的文件夹，比如Objective-C的分类文件夹Category、swift扩展类的文件夹Extension，管理单例类文件夹Manager等等；Vendor，手动管理的第三方库，上图的BookRoom是我们FCS app的BookRoom模块都是封装为framework的形式引入的，所以就适合在此处添加，还有一些比较轻的第三方库就可以手动拖入代码添加进来，比如我们的项目中有一个获取适配型号的第三方库DeviceUtil，对于这类比较轻的库尽量使用手动拖入代码管理，毕竟项目中的framework多了，会影响app的启动时间，这个在WWDC 2016 Session 406 - Optimizing App Startup Time的演讲中有讲原理；Pods ：优秀的第三方库管理工具，比如网络请求AFNetworking，图片加载SDWebImage等等比较重的第三方库就可以使用Pods自动管理，当然你也可以使用Carthage来管理，具体使用哪个见仁见智，网络上也有很多关于这个的讨论。我们公司使用的是Pods，所以就是以Pods为🌰了；Appdelegate和首页：Appdelegate和首页是各个功能模块的入口，所以放在顶部最显眼的位置，（对于传统Tabbar+NavigationBar App的首页类文件可能会在对应的模块下）；Assets.xcassets、info.plist：这部分相对Appdelegate在同一目录下，但是放在最下面，这部分的操作频率不是太多，Assets.xcassets里面的图片，可以使用功能模块放置添加（New Folder，以模块命名）。 看到这里，有的人会想：一个项目直接按照功能模块划分不也挺好的么，每个功能模块里面再按照MVC的模式划分，以下面这个app为例划分如下所示如下图所示：这两种搭建项目框架的模式没有孰优孰劣之分，只有得放到具体情境下面讨论才有意义，不过很明显，第二种以功能模块划分的模式适用于以小团队开发（iOS端2-3人以下），这样每个人负责开发一个模块，效率非常高。如果团队人员比较多，则更适合采用第一种模式，这样开发效率更高，比如有人专门负责，网络层代码的编写，有人专门负责UI界面的编写，有人负责日志类的封装编写。 一些其他的小建议： 文件夹模块使用英文而不要使用中文命名，并且使用正确的英文名不要使用拼音； 名称首字母大写； 文件夹层数不要太多，最多三层； 快速定位某一个类文件的位置，光标在定位在类文件里面，按快捷键command+shift+J并可定位他的具体位置模块。 demo的GitHub地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个iOS开发者的android修行之路三：布局开发单位对比(pt VS dp)]]></title>
    <url>%2F2017%2F12%2F12%2F2017-12-12%2F</url>
    <content type="text"><![CDATA[说到布局和适配，就不得不谈论下iOS和Android二者布局的单位：pt(point，点)和dp(Device independent pixel,Density independent pixel, DIP, DP，又叫与设备无关像素或与密度无关像素或密度独立像素)。注意：这里说的point和和印刷行业的单位point(1pt = 1/72 inch)是有区别的，看到好多文章都将iOS的pt和印刷行业的pt单位给等同起来这非常的误人子弟。 先说结论： 相同点：都是为了适配不同屏幕不同尺寸的移动设备而设计出来的一种单位，用于表示UI布局尺寸与设备屏幕密度无关 不同点：一：pt是iOS设备的布局尺寸单位，苹果公司给的定义是：1pt = 1/163 inch，dp是android设备的布局尺寸单位，Wikipedia给的定义对于android设备：1dp = 1/160 inch；二：像素(pixels)和二者的转换关系不同：iOS pt = pixels * ( ppi/163)、Android dp = pixels * (ppi/160) 在说二者的异同之前，我们得先清楚几个概念(以下概念都是在屏幕、显示器这个语境下的定义讨论的)： inch：英寸，长度单位，1英寸 = 2.54 厘米； px：pixels，像素，组成图片、视频的基本显示单位； dpi：dots per inch，每英寸的点数又叫点密度；可以和下面的ppi概念等同 ppi：pixels per inch，每英寸的像素值又叫像素密度，每英寸像素值越高，屏幕能显示的图像也越精细，5ppi表示每平方英寸有5*5个px 屏幕尺寸(screen size)：最通俗的理解就是：屏幕对角线的长度，如5.8英寸的iPhoneX； 屏幕分辨率(resolution)：手机的屏幕分辨率代表横向和纵向的像素值，如上图iPhoneX的分辨率是1125px * 2436px 通过上面的定义，我们知道ppi、屏幕尺寸、屏幕分辨率这三者的关系为： ppi = 屏幕对角线的像素值/屏幕尺寸 = √ (屏幕横向像素值^2 + 屏幕纵向像素值^2)/对角线长度根据上面的公式，我们计算下iPhoneX的像素密度为：√ (1125^2 + 2436^2)/5.8 ≈ 458ppi px、pt、dp的相互转换 px、pt、dp是静态测量 - 它们不会因其他因素而改变；1px总是1px，是可以显示颜色的屏幕中最小的一块。1pt总是1pt，是一个抽象单位，只有与其他点相关时才有意义，dp同理。 pt、dp与px不同，因为它们根据ppi更改大小：在iPhone上，当屏幕像素密度为163ppi时，也就是Retina显示屏时代之前，所有的iPhone（iPhone 2G, 3G, 3GS），1pt等于1px；在326ppi上(iPhone 4,5和6)，1pt等于2px*2px，或总共4px素，意味着你的100x100图像将渲染在Retina设备上将是163ppi设备的四分之一大小；在401ppi上(iPhone 6Plus、7Plus、8Plus)这样的，1pt等于3px*3px，或者9px。iPhone所有机型的分辨率如下图： 参考文章： Mobile design 101: pixels, points and resolutions The Ultimate Guide To iPhone Resolutions iOS 的 APP 在系统中如何适应 iPhone 5s/6/6 Plus 三种屏幕的尺寸]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个iOS开发者的android修行之路二：UITableView和ListView的对比探究]]></title>
    <url>%2F2017%2F11%2F28%2F2017-11-28%2F</url>
    <content type="text"><![CDATA[尽管现在主流的移动设备的屏幕尺寸都越来越大，特别是iPhone X的出现，以后的趋势都是全屏手机，但是一屏的显示的内容还是有限的，当我们需要有大量数据需要展示时就可以使用这两个控件。这两个控件的相同点都是允许用户上下滑动，以便展示屏幕区域外的内容。很多主流的应用，比如微信、QQ的消息列表，微信朋友圈，微博等等应用的很多界面都是使用这两个控件实现的。 UITableView的基本使用 iOS添加一个UITableView有两种方式。一是：纯代码初始化一个UITableView；二是在storyboard中直接拖入一个UITableView并且设置约束添加，同时设置tableView的dataSource和delegate为ViewController。这两种方式并没有优劣之分，使用第二种方式是苹果推荐的快速开发的方式。我的事例代码选择的第二种方法。 自定义UITableViewCell，勾选同时勾选xib,我这里命名为TestTableViewCell，里面添加两个控件ImageView和Label，同时设置应用。同时设置xib中的重用identifier为：TestTableViewCell。 注册重用的cell，在ViewController的viewDidLoad方法中注册自定义cell。 12let nib = UINib(nibName: "TestTableViewCell", bundle: nil)tableView.register(nib, forCellReuseIdentifier: "TestTableViewCell") 配置tableView显示的数据源，实际项目中为网络请求的数据，demo中为模拟了100条假数据。 实现tableView的数据源和代理方法。其中这两个数据源方法必须实现：func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int和func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell，否则会app会闪退。其中第一个方法用来指明cell的个数，第二个方法用来设置cell的数据，demo中的设置UIImageView和UILabel。cell点击事件的响应，则需要实现代理方法func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)下面是整个ViewController代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//// ViewController.swift// iOSTableViewDemo//// Created by romance on 2017/11/28.// Copyright © 2017年 firstleap. All rights reserved.//import UIKitfinal class ViewController: UIViewController &#123; @IBOutlet weak var tableView: UITableView! final fileprivate var dataList = [TestModel]() override func viewDidLoad() &#123; super.viewDidLoad() let nib = UINib(nibName: "TestTableViewCell", bundle: nil) tableView.register(nib, forCellReuseIdentifier: "TestTableViewCell") setupData() &#125; private func setupData() &#123; for _ in 0...100 &#123; let model1 = TestModel(imageName: "set_icon_about", title: "关于") dataList.append(model1) let model2 = TestModel(imageName: "set_icon_change", title: "头像") dataList.append(model2) let model3 = TestModel(imageName: "set_icon_clean", title: "清楚") dataList.append(model3) let model4 = TestModel(imageName: "set_icon_edit", title: "修改") dataList.append(model4) &#125; &#125; &#125;extension ViewController: UITableViewDataSource, UITableViewDelegate &#123; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dataList.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "TestTableViewCell", for: indexPath) as! TestTableViewCell let model = dataList[indexPath.row] cell.icon?.image = UIImage(named: model.imageName); cell.title?.text = model.title return cell &#125; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; tableView.deselectRow(at: indexPath, animated: true) let model = dataList[indexPath.row] let showtitle = model.title let label = UILabel(frame: CGRect(x: 0, y: 0, width: 100, height: 30)) label.text = showtitle label.textAlignment = .center label.backgroundColor = .lightGray label.center = view.center label.alpha = 0 self.view.addSubview(label) UIView.animate(withDuration: 0.25, animations: &#123; label.alpha = 1 &#125;) &#123; (b) in DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2, execute: &#123; UIView.animate(withDuration: 0.25, animations: &#123; label.alpha = 0 &#125;, completion: &#123; (b) in label.removeFromSuperview() &#125;) &#125;) &#125; &#125;&#125; ListView的基本使用 在activity_main.xml中添加ListView布局，充满父容器，其实iOS中的storyboard和xib文件也是xml语言编写（也就是说和android的xml文件类似），只不过苹果公司开发Xcode可以图形化界面进行设置约束，而Android Studio尽管也可以通过拖控件进行布局，但是一般都不使用。 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/list_view" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 设置ListView子项布局test_item.xml。 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/test_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/set_icon_about"/&gt; &lt;TextView android:id="@+id/test_tile" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="hehe" android:textSize="21sp" android:layout_marginLeft="8dp"/&gt;&lt;/LinearLayout&gt; 自定义ListView的适配器TestAdapter。 1234567891011121314151617181920212223242526272829303132333435363738public class TestAdapter extends ArrayAdapter &#123; private int resourceID; public TestAdapter(@NonNull Context context, int resource, List&lt;TestModel&gt; objects) &#123; super(context, resource,objects); resourceID = resource; &#125; @NonNull @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; TestModel testModel = (TestModel)getItem(position); View view; ViewHolder viewHolder; if (convertView == null) &#123; view = LayoutInflater.from(getContext()).inflate(resourceID, parent, false); viewHolder = new ViewHolder(view); view.setTag(viewHolder); &#125; else &#123; view = convertView; viewHolder = (ViewHolder)view.getTag(); &#125; viewHolder.imageView.setImageResource(testModel.getImageID()); viewHolder.textView.setText(testModel.getTitle()); return view; &#125; class ViewHolder &#123; ImageView imageView; TextView textView; ViewHolder(View view ) &#123; imageView = (ImageView)view.findViewById(R.id.test_image); textView = (TextView)view.findViewById(R.id.test_tile); &#125; &#125;&#125; 添加Adapter数据，同iOS类似，demo添加了100条假数据。 在onCreate方法中创建一个TestAdapter对象adapter，并且设置为listView的适配器。为ListViewitem子项添加点击事件。MainActivity的代码如下：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private List&lt;TestModel&gt; dataList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initsData(); TestAdapter adapter = new TestAdapter(MainActivity.this,R.layout.test_item,dataList); ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; TestModel model = dataList.get(i); Toast.makeText(MainActivity.this,model.getTitle(),Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void initsData() &#123; for (int i = 0; i &lt; 100; i ++) &#123; TestModel testModel = new TestModel(R.drawable.set_icon_about,"关于"); dataList.add(testModel); TestModel testModel2 = new TestModel(R.drawable.set_icon_change,"头像"); dataList.add(testModel2); TestModel testModel3 = new TestModel(R.drawable.set_icon_clean,"清楚"); dataList.add(testModel3); TestModel testModel4 = new TestModel(R.drawable.set_icon_edit,"修改"); dataList.add(testModel4); &#125; &#125;&#125; UITableView和ListView的对比相同点： 都有重用机制，来提高滑动性能； 见文章开头所写； 不同点： UITableView继承自UIScrollView是一个滑动的View，而ListView则不是集成ScrollView。（或许这两点并没有没有可比性，毕竟是两个不同框架提供的库） UITableView有两种样式，group和plain。而ListView只有一种类似于iOS的plain模式， 最后，文中使用的控件对比：iOS图片显示控件UIImageView与Android的ImageView控件对应，文本显示控件iOS是UILabel，对应Android的TextView。GitHub demo地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个iOS开发者的android修行之路一：UIViewController与Activity的生命周期对比探究]]></title>
    <url>%2F2017%2F11%2F24%2F2017-11-24%2F</url>
    <content type="text"><![CDATA[先说说自己学习安卓的一个初衷，在移动app开发的过程中，经常和android开发人员讨论一些技术的实现，有时候交流起来就特费劲，不是他听不懂我说的术语，就是他听不懂我讲的什么，反正就是有点语言不通，比如：iOS中的集合视图UITableView、UICollectionView中每个子项一般叫做cell，讨论的时候也叫做cell中干啥干啥，而安卓中的集合视图ListView,GridView,RecyclerView的每一个子项叫做item，这个还是小的差异；还有就是讨论某个UI界面数据刷新是什么时机进行刷新的，我说我们这边是在viewWillAppear的时候进行刷新，然后android那边就懵逼了，直到我换了一种说法，就是在这个页面即将显示的时候刷新数据，对方才听懂；而有时候我们听到对方的一些名词的时候，会想这Activity是什么东东？Fragment又是什么？于是我们会联想这对应到我们iOS这边相应的是什么。总之，诸如此类的听到对方说的一些名词自己云里雾里的。其实，一个更为重要的原因是想要成为移动开发的leader，你不懂一些android的开发，以及了解android和iOS的一些差异，你是没法胜任这个工作的。有时候，android遇到一些坑时，你必须知道如何高效的解决。如何和小组开发人员探讨某个问题的最佳实践。 Activity的生命周期一个优秀app必须兼顾两个必要条件：1、优秀的界面，2、良好的用户交互体验。在iOS中是由UIViewController主要负责加载界面呈现给用户，以及处理用户的交互逻辑；而安卓负责界面展示和交互功能就是Android系统四大组件之一的活动Activity。1. 我们先看下iOS的UIViewController的生命周期函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class BaseViewController: UIViewController &#123; // 前两个init方法是UIViewController的初始化方法 // 非storyboard加载会调用此方法 override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123; super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil) print("\(self)\(#function)") &#125; // 使用storyboard加载的UIViewController会调用此初始化方法 required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) print("\(self)\(#function)") &#125; // 视图的@IBOutlet和@IBAction链接完成再次方法中 override func awakeFromNib() &#123; super.awakeFromNib() print("\(self)\(#function)") &#125; // Creates the view that the controller manages. // 此方法一般调用的少 override func loadView() &#123; super.loadView() print("\(self)\(#function)") &#125; // Called after the controller's view is loaded into memory. // 控制器视图加载完成（加载到了内存）的时候调用,只被调用一次，我们一般在这个方法中进行数据的网路请求，约束的设置，以及视图的一些操作等等。 override func viewDidLoad() &#123; super.viewDidLoad() print("\(self)\(#function)") &#125; // MARK: -分割线----上面的方法只会调用一次，下面的方法除了deinit方法可能会调用多次 // Notifies the view controller that its view is about to be added to a view hierarchy. // 视图即将显示的时候调用 override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) print("\(self)\(#function)") &#125; // Called to notify the view controller that its view is about to layout its subviews. // 控制器视图即将布局他的子视图时调用 override func viewWillLayoutSubviews() &#123; super.viewWillLayoutSubviews() print("\(self)\(#function)") &#125; // Called to notify the view controller that its view has just laid out its subviews. // 控制器视图已经布局完其子视图后调用，在iphone X的适配就是在此方法中获取view.safeAreaInsets进行处理的， override func viewDidLayoutSubviews() &#123; super.viewDidLayoutSubviews() print("\(self)\(#function)") &#125; // Notifies the view controller that its view was added to a view hierarchy. // 试图已经完全显示的时候调用 override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) print("\(self)\(#function)") &#125; // Notifies the view controller that its view is about to be removed from a view hierarchy. // 视图即将被移除的时候调用 override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) print("\(self)\(#function)") &#125; // Notifies the view controller that its view was removed from a view hierarchy. // 视图已经被完全移除的时候调用 override func viewDidDisappear(_ animated: Bool) &#123; super.viewDidAppear(animated) print("\(self)\(#function)") &#125; // Sent to the view controller when the app receives a memory warning. // 手机收到内存警告的时候调用 override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() print("\(self)\(#function)") &#125; // 视图被销毁的时候调用，在这里可以执行的操作有：KVO移除，通知的移除，定时器的销毁 deinit &#123; print("\(self)\(#function)") &#125;&#125; 下面是从ViewController跳转到SecondViewControler在跳转到ThirdController控制台的log：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;init(coder:)&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;awakeFromNib()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;loadView()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidLoad()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewWillAppear&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidAppear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;init(coder:)&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;awakeFromNib()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;loadView()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidLoad()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewWillDisappear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillAppear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidDisappear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidAppear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;init(nibName:bundle:)&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;loadView()&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewDidLoad()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillDisappear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewWillAppear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewWillLayoutSubviews()&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewDidLayoutSubviews()&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidDisappear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewDidAppear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewWillDisappear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillAppear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;viewDidDisappear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidAppear&lt;LifecycleDemo.ThirdViewController: 0x7fd122c2ff00&gt;deinit&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewWillDisappear&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewWillAppear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;viewDidDisappear&lt;LifecycleDemo.ViewController: 0x7fd122d0b5d0&gt;viewDidAppear&lt;LifecycleDemo.SecondViewController: 0x7fd122c16480&gt;deinit 2. 我们再来看下android的Activity的生命周期函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class BaseActivity extends AppCompatActivity &#123; String str = this.getClass().getName(); /*活动第一次被创建的时候调用，布局的加载，事件的绑定可以在这里完成,此时活动还是不可见的*/ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.i(str,"onCreate"); &#125; /*活动由不可见变为可见的时候调用*/ @Override protected void onStart() &#123; super.onStart(); Log.i(str,"onStart"); &#125; /*活动已经完全可见，并且可以与用户交互，活动处于返回栈的栈顶*/ @Override protected void onResume() &#123; super.onResume(); Log.i(str,"onResume"); &#125; /*在系统准备启动或者恢复一个activity时调用*/ @Override protected void onPause() &#123; super.onPause(); Log.i(str,"onPause"); &#125; /*当activity 完全不可见的时候调用*/ @Override protected void onStop() &#123; super.onStop(); Log.i(str,"onStop"); &#125; /*活动被重新启动的时候调用*/ @Override protected void onRestart() &#123; super.onRestart(); Log.i(str,"onRestart"); &#125; /*acitivity被销毁前调用，调用之后，activity变为销毁状态*/ @Override protected void onDestroy() &#123; super.onDestroy(); Log.i(str,"onDestroy"); &#125;&#125; 下面是一个MainActivity跳转到SecondActivity，然后在回来的生命函数调用在控制台输出的log：1234567891011121314I/com.example.xcqromance.lifecycledemo.MainActivity: onCreateI/com.example.xcqromance.lifecycledemo.MainActivity: onStartI/com.example.xcqromance.lifecycledemo.MainActivity: onResumeI/com.example.xcqromance.lifecycledemo.MainActivity: onPauseI/com.example.xcqromance.lifecycledemo.SecondActivity: onCreateI/com.example.xcqromance.lifecycledemo.SecondActivity: onStartI/com.example.xcqromance.lifecycledemo.SecondActivity: onResumeI/com.example.xcqromance.lifecycledemo.MainActivity: onStopI/com.example.xcqromance.lifecycledemo.SecondActivity: onPauseI/com.example.xcqromance.lifecycledemo.MainActivity: onRestartI/com.example.xcqromance.lifecycledemo.MainActivity: onStartI/com.example.xcqromance.lifecycledemo.MainActivity: onResumeI/com.example.xcqromance.lifecycledemo.SecondActivity: onStopI/com.example.xcqromance.lifecycledemo.SecondActivity: onDestroy 通过上面的对比，我整理出iOS和android的生命周期函数有及其相似的地方和不同之处： GithubDemo地址，里面有上述操作的代码，文章写的有点粗糙，同时欢迎大家一切探讨。一起添加iOS和android的生命周期的异同。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS11,iPhoneX适配,Xcode9遇到的问题以及解决方案探讨]]></title>
    <url>%2F2017%2F10%2F19%2F2017-10-19%2F</url>
    <content type="text"><![CDATA[以下问题是自己在升级Xcode9后，在iOS11设备运行项目后遇到的问题，在此记录，说不定你也到过类似的问题，我们可以一起探讨，解决问题。 自定义导航栏高度无效使用Xcode9和Xcode8运行同样一份代码，Xcode8中运行到iOS11系统的手机上导航栏高度是自定义的高度，而Xcode9运行高度就成了系统的44pt的高度了；目前还没有找到有效的解决方案；之前iOS11beta5版本苹果给修复了这个bug，正式系统发布后又出现了这个问题； 区别如下：自定义UINavigationBar代码如下：1234567891011121314151617181920public let customNavigationBarHeight: CGFloat = isPad ? 75 : 60final class CustomNavigationBar: UINavigationBar &#123; override func sizeThatFits(_ size: CGSize) -&gt; CGSize &#123; return CGSize(width: UIScreen.main.bounds.width, height: customNavigationBarHeight) &#125; override func layoutSubviews() &#123; super.layoutSubviews() for subview in subviews &#123; subview.center.y = frame.height / 2 &#125; &#125; override func titleVerticalPositionAdjustment(for barMetrics: UIBarMetrics) -&gt; CGFloat &#123; return -(frame.height - 44)/2 &#125;&#125; 在stackeroverflow曾经搜索到一个解决方案的确能够在iOS11设备上修改导航栏高度，但是存在两个问题：第一导航栏标题栏不垂直居中；第二导航控制器的rootviewcontroller如果是tableVeiwController或者有tableView的topInset还是44pt，没有相应的跟着导航栏的高度下移：重写layoutSubviews()的方法如下：1234567891011121314151617181920override func layoutSubviews() &#123; super.layoutSubviews() backgroundColor = .black frame = CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: customNavigationBarHeight) for subview in self.subviews &#123; printLog(subview) let stringFromClass = NSStringFromClass(subview.classForCoder) if stringFromClass.contains("BarBackground") &#123; subview.frame = CGRect(x: 0, y: 0, width: self.frame.width, height: customNavigationBarHeight) subview.backgroundColor = .blue//self.backgroundColor &#125; else if stringFromClass.contains("BarContent") &#123; subview.frame = CGRect(x: subview.frame.origin.x, y: 0, width: subview.frame.width, height: customNavigationBarHeight) subview.backgroundColor = .red//self.backgroundColor subview.center.y = customNavigationBarHeight / 2 &#125; else &#123; subview.center.y = frame.height / 2 &#125; &#125;&#125; 效果和分析图如下：这个问题还有待进一步探讨解决方案，如果哪位有解决方案，我们可以一起探讨下！ 使用Xcode9打包上传构建版本时，收到警告，意思是缺少1024x1024px的Icon图片；解决方案：在项目Assets.xcassets的AppIcon中添加一张要求尺寸的Icon图片；邮件内容如下1234567891011Dear developer,We have discovered one or more issues with your recent delivery for &quot;励步云学习&quot;. Your delivery was successful, but you may wish to correct the following issues in your next delivery:Missing Marketing Icon - iOS Apps must include a 1024x1024px Marketing Icon in PNG format. Apps that do not include the Marketing Icon cannot be submitted for App Review or Beta App Review.After you’ve corrected the issues, you can use Xcode or Application Loader to upload a new binary to iTunes Connect.Regards,The App Store team 同时记得叫UI添加iPhone X的LaunchImage。 swift版本不匹配的问题如果我们项目中使用的一些依赖库是使用swift语言构建的framework，从Xcode8升级到Xcode9后是编译不过的，提示swift Module版本不匹配的错误，此时我们只需要使用Xcode9重新编译对应的framework就能够编译通过。 添加用户隐私协议提交AppStore审核，审核时间将近一个月被拒我们公司国庆放假前一两周提交了一个版本，解决了iOS11的一些闪退和适配问题，同时添加了用户隐私条款，结果国庆放假回来之后还在审核中，审核期间我们发了无数封加急邮件，但是一直都是的回复都是正在审核！后面经过排查很打原因是用户隐私策略的添加导致的，尽管这个用户隐私协议条款的内容是公司集团法务提供的，但是好像苹果公司还得审核你的隐私协议内容。后面果断撤回这个版本（大量用户升级iOS11系统后反馈app里面的一个播放视频模块闪退，后面锁定原因是我们建立的播放视频类类名和系统的类重名了），去除隐私条款再重新提交一个新的构建版本，再写一封加急邮件，第二天立马通过审核。几天后，同时集团的其他部门提交的包含隐私策略的版本被拒，血的教训，血的坑啊！ iOS11系统设备保存图片到系统相册闪退解决方案：在info.plist中添加访问权限，key:NSPhotoLibraryAddUsageDescription,value:是否允许$(PRODUCT_NAME)访问你的相册？。 tableView在iOS11设备两边留白如左下图红色方框留白间隙部分，以及解决后的效果右下图：解决方案：123if #available(iOS 9.0, *) &#123; tableView.cellLayoutMarginsFollowReadableWidth = false&#125; iphoneX的适配问题由于我们公司项目中大部分都是使用storyboard开发用autolayout进行布局，所以整个iPhoneX的布局适配只花了一天就完成。iPhoneX的适配规则我认为很简单：根据苹果建议的规则以及UI给你的效果图进行修改，比如我们这边是使用苹果官方推荐的左右留白相应的距离，在安全区域(Safe Area)内布局，安全区域外的内容就别添加点击事件。具体可以查看下这两篇文章三分钟弄懂iPhone X 设计尺寸和适配，关于 iPhone X 产品汪和设计狮应该了解的事之四，看完这两篇文章你对iPhoneX也就基本了解了。先看一组界面错乱的UI AutoLayout布局的iPhoneX适配；很多项目的部署版本可能是低于iOS9的，那么Safe Area Layout Guides布局就不支持，但是这并不影响在iPhoneX的自动适配。刚升级到Xcode9时报的一个storyboard的错误就是Safe Area Layout Guides before iOS 9.0，应为这个选项默认是打开的，我们只需将其关闭就行。第一、像tableView，collectionView这种集合视图，autolayout已经给我们自动适配好了，我们不需要做过多的修改。如上图，左右下三边的白色部分就是自动适配好了距离，我只需将这部分颜色改为tableview的深色就适配好了。第二、上图顶部黄色区域内的左右两边距离还得添加view.safeAreaInsets左右两边的距离，这部分的适配只需将约束引出一个IBOutlet，然后在viewDidLayoutSubviews方法中重新设置，具体代码如下：1234567891011@IBOutlet weak var backBtnLeadingCons: NSLayoutConstraint!@IBOutlet weak var stageViewTrailingCons: NSLayoutConstraint!override func viewDidLayoutSubviews() &#123; super.viewDidLayoutSubviews() if #available(iOS 11.0, *) &#123; let inset = view.safeAreaInsets printLog(inset) backBtnLeadingCons.constant = inset.left + 20 stageViewTrailingCons.constant = inset.right + 10 &#125;&#125; 修改后的效果图：还有一点要注意的是：使用Auto Layout的距离底部约束的区别，勾选第一个是下图左边的布局，勾选下面一个是下图右边与底部挨着对齐的布局。具体选哪种这个得更具产品要求设置即可，我这里选择第二种，与底部对齐，因为底部并没有与用户交互的事件，这样做更加符合审美。 代码约束(如Masonry)或者手写控件frame适配iPhoneX这种情况的就需要单独针对iPhoneX写一套约束或者控件的frame。此时我们可以在定义一个全局常量(以swift为例):1234// 屏幕宽高let kScreenWidth = UIScreen.main.bounds.size.widthlet kScreenHeight = UIScreen.main.bounds.size.heightlet isiPhoneX = (max(kScreenWidth, kScreenHeight) == 812 &amp;&amp; min(kScreenWidth, kScreenHeight) == 375) 暂时遇到的问题就这么多，以后遇到坑在添加，同时欢迎大家添加遇到的坑！]]></content>
  </entry>
  <entry>
    <title><![CDATA[将项目中公共组件使用Cocoapods管理实战]]></title>
    <url>%2F2017%2F08%2F25%2F2017-08-25%2F</url>
    <content type="text"><![CDATA[想直接操作上手的请略过前言部分，直接阅读正文部分；建议不要错过精彩的前言哦，或许你看了对你有所启发。 前言随着项目的发展，版本迭代，代码的重构，我们项目中一般会有很多有业务功能行性公共的组件，app中可能多处都会使用到，甚至别的项目中也需要使用。比如我们FCS项目中有一个语音评测的功能，前期只是在FCS项目里面需要用到，后面在另一不同项目绘本阅读需要用到相同语音评测的功能。此时我们一般有两种做法，一是直接将这部分代码copy到绘本阅读这个项目中；二是将语音评测这部分逻辑给抽取出来，然后在分别在两处使用。很明显在项目初期，或者时间紧迫的情况下，第一种方式很好的能够胜任工作，我们前期也是这么做的，但是我发现到了随着项目的推移和发展，这样做的时间成本太大了，效率也很低下，有很多隐患(评测逻辑一旦有变动，你需要改动两次，而且你没法保证两次的改动一致)。正确的做法是在适当的时间应该立马进行代码重构，将这部分重复的代码给抽取出来。至于重构的准则就是三次法则，出自Martin Fowler《重构改善既有代码的设计》，这本书真的推荐大家一看，程序员必读的书籍之一。扯远了。。。 于是我花了几天时间将语音评测这部分逻辑给抽取出来，建立了一个公共组件SpeechEvaluationKit，在两个项目中都能够方便的使用，并且使用Cocoapods来管理。公司项目的核心代码存放在Coding上，包括SpeechEvaluationKit的代码，这部分代码我们是不能够公开的，所以我建立的是私有库(Private Pods)，也是本文实战操作所建立私有库管理；相对应的当然就有公有库，这部分的代码不仅可以自己使用，还可以开源出来。 正文关于CocoaPods的介绍、安装、使用说明请查看官方文档，同时本文的操作也是根据官方文档介绍来完成的。如下图，项目的目录结构如下图： 新建[项目名].podspec使用命令：pod spec create &#39;项目名&#39;、pod lib create &#39;项目名&#39;。现有的项目，在项目根目录运行终端命令：pod spec create &#39;SpeechEvaluationKit&#39;，根目录下将会生成一SpeechEvaluationKit.podspec文件。如果还没有创建项目，则使用pod lib create &#39;SpeechEvaluationKit&#39;，这一步会让你填写一些信息比如使用swift还是oc、是否使用测试框架等等，我的选择如下：最终生成的的目录如下，新建项目写完代码后得将本地仓库添加到远程git仓库，关联命令为git remote add origin 远程仓库地址 配置podspec文件12345678910111213Pod::Spec.new do |s| s.name = &apos;SpeechEvaluationKit&apos; s.version = &apos;1.0.0&apos; s.summary = &apos;SpeechEvaluationKit is a powerful voice evaluation library&apos; s.description = &apos;A powerful voice evaluation library，such as book reading, living and ips mission.&apos; s.homepage = &apos;https://git.coding.net/firstleap/SpeechEvaluation_iOS.git&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;XcqRomance&apos; =&gt; &apos;xcqromance@163.com&apos; &#125; s.source = &#123; :git =&gt; &apos;https://git.coding.net/firstleap/SpeechEvaluation_iOS.git&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; s.source_files = &apos;SpeechEvaluationKit/Classes/**/*&apos; s.exclude_files = &quot;SpeechEvaluationKit/Assets/**&quot;`end 这个podspec文件包含的信息很重要，对于一个普通的pods库上面的信息就足够了，各个配置的含义基本都能够看得懂，比如name代表你的pods库的名字，如果是公有pods库，可以通过pod search name来搜索查看；version则代表版本号，一旦库有发布更新就通过修改这个版本号来发布更新；summary和description就是对pods库的简介和详细说明，这个根据库的功能来描述；source一般填写代码仓库地址可以是git、svn、github的地址；source_files代表你这个pods库包含的代码，一般就是我们编写公共组件的代码，文件的描述都是可以用一些匹配公式，比如上面用到的**和*；exclude_files一般是除了代码之外的资源文件，比如图片、音频之类的;至于其他信息，你可以根据自己库的需求来配置，比如YTKNetwork是基于AFNetworking的封装，所以还添加了s.dependency &quot;AFNetworking&quot;, &quot;~&gt; 3.0&quot;依赖。上面的这些信息必须读严谨的配置，否则在下一步验证的时候会出现警告甚至报错不通过。比如我之前的summary没有更改而是使用的模版信息，就出现如下警告： 验证podspec文件和项目(pod lib lint Name.podspec)执行命令pod lib lint SpeechEvaluationKit.podspec（后面还可以添加参数--verbosev，有助于出错的问题定位）一般到这一步会遇到很多警告和错误导致验证不通过，此时不要心急，一个一个问题解决，在stack overflow寻找解决方案，你所遇到的问题，前人们很多都已经遇到过了。验证通过提示信息如下：一旦验证通过，你就离成功只有一步之遥了； 建立tag，并且上传git仓库，tag版本和podspec文件的version版本保持一致就行了；git 常见命令传送门12git tag -a 1.0.0 -m &apos;pod私有仓库&apos; #打taggit push origin 1.0.0:1.0.0 #上传tag 发布项目到cocoapods官方仓库等等…在这之前你得先有一个Cocoapods账号，也就是得先注册一个账号，执行以下命令：pod trunk register romance.xie@firstleap.cn &#39;romance&#39; --description=&#39;My working computer&#39;邮箱、名字、描述该为自己的就行，然后你将会邮箱会收到一封邮件，点击右键链接激活，然后通过pod trunk me来查看自己是否注册成功：如果是多人开发，只需执行命令：pod trunk add-owner &#39;项目名&#39; &#39;邮箱&#39;将伙伴添加到项目中； 公有库的发布(即开源的，会将podspec文件上传到cocoapods官网，当执行pod install 或者 pod update的时候会根据配置文件取对应的源代码)发布命令：pod trunk push 项目名.podspec使用pod search 项目名查看是否上传成功，下图是我们app中日志收集的公有库FLogKit，pod search FLogKit 私有库的发布发布命令：pod repo add &#39;仓库名&#39; &#39;仓库地址&#39;如果是现有的项目，代码放在coding私有项目中，仓库地址直接填写第2步podspec配置文件的s.source的地址，即执行以下命令即可：pod repo add &#39;SpeechEvaluationKit&#39; &#39;https://git.coding.net/firstleap/SpeechEvaluation_iOS.git&#39;;如果是新建的项目，即第1步中，使用pod lib create &#39;项目名&#39;初始化的项目，就需要先在服务器建立一个私有仓库，我这里以在Coding中建立私有仓库为例，仓库建立好后将会有获得git仓库地址，记得将写好的代码提交到Coding的Git仓库中，执行发布命令pod repo add &#39;SpeechEvaluationKit&#39; &#39;https://git.coding.net/romance/SpeechEvaluationKit.git&#39;;使用open ~/.cocoapods/repos查看是否创建好私有仓库，一旦代码有更新，使用pod repo update更新pod私有仓库，删除私有仓库pod repo remove &#39;项目名&#39;。 使用组件pod &#39;SpeechEvaluationKit&#39;, :path =&gt; &#39;../&#39;，开发模式pod &#39;SpeechEvaluationKit&#39;，稳定之后或者其他项目的使用 总结看完本文知道Cocoapods管理公共组件是多么简单了吧，当然里面一些深入的内容需要在实际使用过程中才领悟了解。整个过程及其使用就只有五步：新建podspec文件-&gt;配置podspec文件-&gt;验证podspec文件和项目-&gt;上传tag-&gt;发布更新。这步骤你记住了么。]]></content>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用TestFlight对iOS app beta版本测试实战]]></title>
    <url>%2F2017%2F08%2F17%2F2017-08-17%2F</url>
    <content type="text"><![CDATA[前言TestFlight是苹果官方提供给开发者对预发布版本进行测试的工具或者说是一种服务。通过本文你将知道如何使用TestFlight添加测试人员以及邀请外部测试人员进行测试。本文参考苹果官方提供的方法教程 我们知道苹果开发者可以申请的账号有三类个人、公司、企业这三大类(其实还有一类就是教育机构，比如大学，但是我们一般用得少，所以不说)苹果官方定义几大分类传送门，个人、公司开发者账号的会员费99$一年，企业级账号是299$一年。 关于在iOS app测试我们知道由于苹果的安全签名机制，我们开发的app想要对外测试(比如给公司客户、领导等等)并不是一件容易的事情。对于企业级账号我们可以之间让用户下载，信任之后直接使用，但是这类app并不能发布到App Store，所以也就无法进行本文所说的TestFlight Beta Testing功能，一般是企业内部使用的app才会选择。对于大部分互联网公司，肯定是选择公司级别的账号，最终需要发布到App Store的，而这类账户的测试就很麻烦，有100台设备限制，而且还得事先获取设备UDID，然后导出ipa，链接itunes安装，总之整个流程下来特别繁琐。当然还有一种是简便方式就是通过第三方的分发平台，比如蒲公英，TestBird；但这不在我们的讨论范围之内。 正文注意：本文的操作都所使用的开发者账号是前言部分说的第二种：99$的Appstore公司开发者账号 提前准备的工作：有手动打包或者自动打包构建好的好的ipa文件。如下图 使用Application Loader上传构建版本到iTunes具体操作如下：Xocode-&gt;Open Developer Tool-&gt;Application Loader登录apple ID账号双击上图箭头指向的框框，选取提交的构建版本根据操作一直下一步，直到成功登录iTunes Connect可以查看提交的构建版本 如果开发团队人员多，建议使用Jenkins+Fastlane进行持续集成，只需要在一台mac电脑进行配置证书之类的，整个团队都可以打包并且自动上传到Appstore，供测试人员下载测试，大大提高整个团队的开发效率；具体配置很简单，网络上有很多教程！（Android的持续集成也支持哟） 创建和添加测试人员你可以在Test Flight中添加两种类型的测试；内部测试：管理员，技术，app管理员，开发人员和营销角色的iTunes Connect用户，这些角色可以访问我们的应用程序。 这通常是您正在开发应用程序的团队成员或客户端。 最多可以添加25个内部测试人员。苹果官方定义内部测试 外部测试：外部测试员可以是任何拥有一个电子邮件地址的用户，应邀为我们的 App 进行 Beta 版测试。外部测试员中可以包括 iTunes Connect 用户，但 iTunes Connect 用户不能同时为内部和外部测试员。而且至多 能添加10,000 个外部测试员。苹果官方定义外部测试 添加内部测试人员登录iTunes Connect按照如下步骤进行设置各个角色对应的权限如下图：这里我选择的角色是App 管理，还可以选择测试的app，我们公司账号有多个app，所以我选择所有app点击下图的存储，查看自己的邮件验证，activate your account，至此添加测试人员完毕。 TestFlight添加测试员进入iTunes Connect 主页点击我的 App，选择TestFlight模块，选择要进行测试的构建版本；然后在左边iTunes Connect 用户一栏将上一步的测试员( romance.xie@100tal.com)添加进来，如下图： 添加外部测试人员 新建一个群组命名为外部测试人员； 添加测试员，有三种方式：添加新测试员、添加现有测试人员、从CSV导入；我这里选择第一种添加新测试员，输入信息后点击添加 添加构建版本(这也是内部和外部测试人员的不同之处，用来区分内部和外部测试人员测试不同的版本)需要注意的是添加的构建版本需要通过Beta版App审核(第一次提交需要2天左右，之后提交会变得很快)； 然后你的外部测试人员的邮件将会收到邀请码 测试Beta app 安装TestFlight App在App Store中搜索TestFlight，安装 当新的测试版本上传到iTunes Connect时，内部测试人员将自动收到电子邮件。 如果测试版本app通过Beta App 审核后，外部测试人员将收到类似的电子邮件，并且该版本已被iTunes Connect中的管理员或应用程序管理员推送到外部测试人员： 在需要测试的设备中打开邮件内容，下面两图是内部测试人员的收到的邮件内容（在添加测试员中的状态下面有个蓝色发送邀请按钮，内部测试人员就会收到邮件了）外部测试的操作也类似，这里不在赘述。 点击上图的蓝色字体打开TestFlightapp，就可以安装测试app了，当有新的构建版本是，你将会受到通知，只需更新到最新版本就可以测试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[app上线后iOS8系统踩过的坑]]></title>
    <url>%2F2017%2F07%2F13%2F2017-07-13%2F</url>
    <content type="text"><![CDATA[项目上线，app最低支持的系统版本是iOS8.0，而我们公司的有一些用户还是使用iOS8的系统一直没有升级，而我们公司没有iOS8的测试机（之前有最后都被升级了）。所以项目上线后用户反馈和Bugly统计了大量的crash日志信息。现在集中记录下有iOS8导致的crash，让后人以免踩坑。 iOS8 Crash总结 项目使用Carthage集成的第三方库YTKNetwork.framework在iOS8系统设备上启动就闪退，闪退信息如下：在GitHub的YTKNetwork下面的issues提问还是没能解决，讨论说是使用Carthage集成就是会存在这么个问题，最后只好将这个库里YTKNetworkAgent.m类中的源码相关requestPriority的部分注释掉才给解决的！ iOS8系统使用的自提示Helvetica，iOS9系统中文系统字体变为了平方(PingFangSC)字体，导致在iOS设备上使用此方法时UIFont *font = [UIFont fontWithName:@&quot;PingFangSC-Medium&quot; size:17]的font为空，进而导致使用这么使用时@{NSFontAttributeName: font}会crash，信息如下：但是如果使用swift的写法就安全多了，我们可以知道let font = UIFont(name: &quot;PingFangSC-Medium&quot;, size: 17)中的font这是个optional值可能为空，我可以给一个默认值。Objective-C解决crash的方案有两种：一是使用先判断是否为nil；二是使用[NSDictionary dictionaryWithObjectsAndKeys:font, NSFontAttributeName, nil];。而且，iOS8系统字体间隙变大导致 UI 显示异常，平方字体比Helvetica字体有轻微的加粗效果，字体间距也变大了，，所以布局方面一些UILabel写死width的就会有问题，解决方案是计算label 的size并且向上取整ceilf(), iOS8中单例中的UIKit类中使用addTarget(_ target: Any?, action: Selector, for controlEvents: UIControlEvents)添加的action事件，并不会随着控制器而销毁，导致第二次并不会执行二是直接crash。GitHub demo地址，ios8模拟器运行效果如下，但是在iOS9+中运行是没有问题的，它对应action会执行两次。这也从另一方面说明单例模式不能够滥用，因为他是常驻内存的，只有当app杀死的时候才能够被释放。我们app用户使用时crash就是因为我们代码写的很不严谨，本不需要使用单例模式却使用了单例模式！ iOS8执行某一个动画时直接crash，并且crash信息如下：&#39;-[CIContext initWithOptions:]: unrecognized selector sent to instance 0x18961850&#39;搜索stackoverflow的解答找到原因是swift的let ciContext = CIContext(options: nil)的原因导致的，最后写了个OC的分类给解决了。另一个解决方案是针对iOS8的系统就不执行动画 iOS8 UITableView crash的信息 Attempt to create two animations for cell，解决方案：stackoverflow的回答 以下是上传到AppStore所遇到的问题 使用Application Loader交付应用时，报如下错误。原因：打包build号没有修改，这个最好写个打包自动修改build号的脚本，人工打包很容易忘记修改build号，脚本自行网上搜索； 2. 使用Application Loader交付应用时，报如下错误信息。原因：使用的一些第三方库如：MJRefresh.framework、SwiftyJSON.framework包含有不支持上线的 x86_64、i386架构；1234ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for leapParent.app/Frameworks/MJRefresh.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for leapParent.app/Frameworks/Pulsator.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for leapParent.app/Frameworks/SnapKit.framework contains unsupported architectures &apos;[x86_64, i386]&apos;.&quot;ERROR ITMS-90087: &quot;Unsupported Architectures. The executable for leapParent.app/Frameworks/SwiftyJSON.framework contains unsupported architectures &apos;[x86_64, i386]’.&quot; 解决方案：添加去除x86_64、i386架构的脚本]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解iOS设计模式]]></title>
    <url>%2F2017%2F05%2F29%2F2017-05-29%2F</url>
    <content type="text"><![CDATA[做 iOS开发也好几年了，记得自己刚入行时，对iOS 开发模式也是一知半解，后面项目做多了，以及看一些优秀书籍之后对他有了进一步的理解；发现自己写的代码中无形之中就用了很多的设计模式，只不过是不知道相应的设计模式术语而已，所以决定把自己做的项目中的一个小模块来写一篇iOS设计模式的文章，一是记录自己的学习；二是让入门者可以作为参考，来理解iOS设计模式。设计模式是软件设计中常见问题的可重复使用的解决方案。 它们是旨在帮助您编写易于理解和重用的代码的模板。 它们还可以帮助您创建松散耦合的代码，以便您可以在代码中更改或替换组件，而不必太麻烦。本文将通过一个小项目的形式来讲解iOS的设计模式。通过跟着我一步一步操作你将学到：什么是设计模式；为什么要使用设计模式；以及怎样在自己的项目中使用合适的设计模式。设计模式分为三大类： 构造模式:单例模式(Singleton)，抽象工厂模式(Abstract Factory)等等； 结构模式:MVC，适配器模式(Adapter)，外观模式(Facade)，装饰模式(Decorator)等等； 行为模式:观察者(Observer)，备忘录(Memento)，命令模式(Command)。整个项目完成将会是如下效果图： 开始鲁代码github上下载starter project，使用Xcode打开项目，这是一个新建的空项目，我将Main.storyboard给删除了，在appdelegate中使用代码设置window的rootViewController为ViewController；以及将books.json放入到了本地，模拟网络请求来的书籍数据(这部分涉及到公司的机密资源，所以只能这样模拟)。 1、使用快捷键Command+N，选择iOS-&gt;Swift File，并且命名为Book,新建一个Book结构体作为模型，并且编写如下代码。(在Objective-C我们一般是新建一个Book类作为模型，但是swift中官方推荐使用结构体，更加轻量级)，此处我使用了JSONExport开源工具生成Book结构体，这是一个很强大的将json转化模型的Mac桌面应用。123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Book &#123; var bid: Int! var bookName: String! var isRead: Bool! var orientation: Int! var pic: String! /** * Instantiate the instance using the passed dictionary values to set the properties values */ init(fromDictionary dictionary: [String: Any])&#123; bid = dictionary["bid"] as? Int bookName = dictionary["book_name"] as? String isRead = dictionary["is_read"] as? Bool orientation = dictionary["orientation"] as? Int pic = dictionary["pic"] as? String &#125; /** * Returns all the available property values in the form of [String:Any] object where the key is the approperiate json key and the value is the value of the corresponding property */ func toDictionary() -&gt; [String:Any] &#123; var dictionary = [String: Any]() if bid != nil&#123; dictionary["bid"] = bid &#125; if bookName != nil&#123; dictionary["book_name"] = bookName &#125; if isRead != nil&#123; dictionary["is_read"] = isRead &#125; if orientation != nil&#123; dictionary["orientation"] = orientation &#125; if pic != nil&#123; dictionary["pic"] = pic &#125; return dictionary &#125; &#125; 当然在实际项目中swift的json解析我们还可以使用GitHub开源的SwiftyJSON，这个也很好用，使用这个就能够减少model类的创建，这个两种使用方式各有各的好吧。 2、Command + N,选择Cocoa Touch Class，命名为BookView作为UICollectionView的子类，language选择Swift；同样操作新建一个BookCell作为UICollectionViewCell的子类，在选择language上面勾选Also create XIB file。新建完毕之后记得在这两个类前面添加final修饰符(这里涉及到代码规范的内容，我后续将会写一篇这样的文章，苹果官方推荐那些些不会继承的类可以添加final修饰，这么做的好处是提高编译速度，当项目庞大的时候优势就明显了，我也深有体会) MVC设计模式Model View Controller(模型视图控制器)是我们所有设计模式中最常用的，他根据程序中的角色对对象进行分类，使代码干净分离，低耦合；Model：保存程序的数据并且定义如何操作它的对象。本例子的Model是结构体Book；View：负责程序UI视觉元素的表示以及与用户的交互响应，基本上所有的UIView及其子类都属于这一类；本例中的View是BookView；Controller：控制器是View和Model之间的协调者，它访问模型中的数据，并且显示于视图，并且监听用户事件并根据需要操作数据；本例中的Controller是ViewController下图很好的显示了这三者之间的关系： 模型数据的变化会通知通知控制器，同时控制器就会更新视图上的数据； 当用户有操作交互时，视图也能通知控制器，于是控制器更新模型中的数据信息。有些人就会有疑问了，为什么不把所有的都写在一个类里面，直接在将视图和模型都写在控制器里面，这样操作起来很容易。我们都知道软件设计有个很重要的原则就是：高内聚，低耦合，所以我们得考虑把代码分离和重用。理想情况下，视图应与模型完全分开。 如果View不依赖于Model的具体实现，则可以使用不同的模型重用其他数据。例如本例中的模型Book，因为不依赖任何视图类，所以可以很简单的重复使用。以及视图类BookView和BookCell，在将来要添加某个功能时完全可以复用，例如我做的真实项目中有个功能模块是书籍的本地下载页面，此时就完全可以复用整个视图类。 基于MVC，我将项目程序分为了三个group，使用快捷键Command+option+N新建三个group，并且命名为Model、View、Controller，同时将相应的源文件拖入相应的分组，如下图： 单例模式(The Singleton Pattern)单例模式能够确保指定类只有一个实例，并且全局可以访问到该实例。苹果官方有大量使用这个模式，比如：UserDefaults.standard、UIApplication.shared、UIScreen.main等等，但是，单例也不能够滥用，因为单例一旦创建他的内存将存在于整个应用程序的一生，直到应用程序被关闭，内存才被释放。本例中：BookAPI类是单例用来处理书籍数据12345678910111213141516171819202122232425262728293031323334353637383940final class BookAPI: NSObject &#123; private var persistencyManager: PersistencyManager private var httpClient: HTTPClient /// 单例 static let sharedInstance = BookAPI() override init() &#123; // 线程安全 persistencyManager = PersistencyManager() httpClient = HTTPClient() super.init() &#125; /// 返回书籍数量 /// /// - Returns: book数组 func getBooks() -&gt; [Book] &#123; return persistencyManager.books &#125; /// 保存书籍数据 func saveBooks() &#123; persistencyManager.saveBooks() &#125; /// 删除指定位置的绘本 /// /// - Parameter index: index 0 func deleteBookAt(index: Int) &#123; httpClient.postRequest(url: "delete/book", params: ["book_id": ""]) &#123; (res) in if res &#123; // 服务器删除成功,删除本地的绘本 persistencyManager.deleteBookAt(index: index) &#125; else &#123; print("删除绘本失败，请稍后再试") &#125; &#125; &#125;&#125; 外观模式(The Facade Pattern) 外观设计模式为复杂的子系统提供单一的接口，只公开一个简单统一的API，而不是将一组类及其API暴露给用户。API的用户完全不知道下面的复杂性。 这种模式在使用大量类时非常理想，特别是当它们复杂使用或难以理解时。外观模式将使用系统的代码与您隐藏的类的接口和实现相分离; 它也减少了外部代码对子系统内部工作的依赖性。 如果外观下面的类改变，那么外部类可以保留相同的API。例如，如果您希望替换后台服务器地址，您将不必更改您的API的代码。在本例中如何使用外观设计模式：目前我们有PersistencyManager来获取本地书籍数据，保存书籍数据；HTTPClient来处理网络请求。我们项目中的其他类将不会知道这个底层逻辑。如下图我们将在BookAPI暴露以下方法来供外部调用：而persistencyManager、httpClient为BookAPI的私有成员变量，不暴露给外部调用； 装饰设计模式(The Decorator Design Patte)装饰设计模式可以在不修改其代码的情况下，动态地向对象添加行为和责任。 就扩展功能来说，装饰设计模式相比于生成子类更为灵活。在Objective-C中，这种模式有两种非常常见的实现：Category(类别)和Delegation(委派)。swift中使用extension为相应的类添加扩展。以下三种情况考虑使用这一模式： 想要在不影响其他对象的情况下，移动台、透明的方式给单个对象添加职责； 想要扩张一个类的行为，却做不到。类定义可能被隐藏，无法进行子类话；或者对类的每个行为的扩展，为支持美中功能组合，将产生大量的子类； 对类的职责的扩展是可选的。 extension本例中的book封面，后台返回的字段&quot;pic&quot;: &quot;/image/20160826/d51285bb636281dce6974313eaf6f15d.png&quot;只是一个路径，前面的域名https://xxxxxx-aliyun.firstleap.cn需要我们这边统一拼接，同时我们使用的阿里云存储服务，有对图片进行处理（包括图片压缩，减少图片分辨率），且iPhone和iPad的处理还不一样。 我们对String添加一个扩展(oc中为category)，File/New/File…,选择Swift File，命名为String+Aliyun，添加以下代码：12345678910111213// 判断型号let isPad = ( UI_USER_INTERFACE_IDIOM() == .pad)let fileHost = "https://xxxxxx-aliyun.firstleap.cn"extension String &#123; func aliyunThumb() -&gt; String &#123; if isPad &#123; return "\(fileHost)\(self)" + "!iPadThumb" &#125; else &#123; return "\(fileHost)\(self)" + "!thumb" &#125; &#125;&#125; Delegation本例中的BookView作为UICollectionView的子类，有两个方法你必须实现，那就是1234// 有多少个itempublic func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int// 每个item需要现实的信息内容public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell 这两个方法都是有BookView的代理ViewController中实现，苹果的UIKit中有很多都是代理委托模式（UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView, UIGestureRecognizer, UIScrollView） ViewController中实现BookView的代理方法如下：1234567891011121314151617181920212223242526272829303132extension ViewController: UICollectionViewDataSource, UICollectionViewDelegate &#123;func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return books.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: &quot;BookCell&quot;, for: indexPath) as! BookCell if indexPath.item &gt; books.count - 1 &#123; cell.coverName.isHidden = true cell.bookCover.isHidden = true cell.isReadImageView.isHidden = true &#125; else &#123; cell.coverName.isHidden = false cell.bookCover.isHidden = false cell.isReadImageView.isHidden = false cell.book = books[indexPath.item] &#125; return cell &#125; func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; let alertVc = UIAlertController(title: &quot;要删除这本绘本么&quot;, message: &quot;&quot;, preferredStyle: .alert) let sureAction = UIAlertAction(title: &quot;确定删除&quot;, style: .default, handler: &#123; (_) in &#125;) alertVc.addAction(sureAction) let cancelAction = UIAlertAction(title: &quot;取消&quot;, style: .default, handler: nil) alertVc.addAction(cancelAction) present(alertVc, animated: true, completion: nil) &#125;&#125; 备忘录模式(The Memento Pattern)顾名思义，备忘录模式用来保存当前程序退出时，当前上下文的文档的数据；在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先的保存状态。当满足以下两个条件时需要考虑使用这一模式： 需要保存一个对象在某一时刻的状态，这样以后就可以恢复到先前的状态； 用于获取状态的接口会暴露细节，需要将其隐藏起来。 在本例中，我在cell的点击事件添加了删除绘本事件，用来删除被点击的书籍，具体代码如下：12345678910111213func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) &#123; let alertVc = UIAlertController(title: "要删除这本绘本么", message: "", preferredStyle: .alert) let sureAction = UIAlertAction(title: "确定删除", style: .default, handler: &#123; (_) in BookAPI.sharedInstance.deleteBookAt(index: indexPath.item) // 发送删除绘本的请求 self.books = BookAPI.sharedInstance.getBooks() // 更新数据源 self.bookView?.deleteItems(at: [indexPath]) BookAPI.sharedInstance.saveBooks() // 保存最新数据，到本地，下次加载app，删除绘本不再显示 &#125;) alertVc.addAction(sureAction) let cancelAction = UIAlertAction(title: "取消", style: .default, handler: nil) alertVc.addAction(cancelAction) present(alertVc, animated: true, completion: nil) &#125; 内部的实现，封装在PersistencyManager对象中，真个思路就是，第一次启动加载budle中的资源(实际项目中需要加在服务器的数据)，然后保存到沙河中，但数据有更新变动时也实时保存数据，整个代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let LibraryCacheDirectory = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!final class PersistencyManager: NSObject &#123; var books = [Book]() override init() &#123; super.init() let fileName = &quot;\(LibraryCacheDirectory)/albums.bin&quot; let fileurl = URL(fileURLWithPath: fileName) let bookdata = try? Data(contentsOf: fileurl) guard let data = bookdata else &#123; // 本地沙河没有数据，所以需要加在bundle中的数据 setupBundleData() return &#125; let json = try! JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [Any] for b in json! &#123; let book = Book(fromDictionary: b as! [String : Any]) books.append(book) &#125; &#125; private func setupBundleData() &#123; let path = Bundle.main.path(forResource: &quot;books&quot;, ofType: &quot;json&quot;) let url = URL(fileURLWithPath: path!) do &#123; let data = try Data(contentsOf: url) let json = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [Any] print(data) // print(json) for b in json! &#123; // print(b) let book = Book(fromDictionary: b as! [String : Any]) books.append(book) &#125; print(books) saveBooks() &#125; catch &#123; print(error) &#125; &#125; func getBooks() -&gt; [Book]&#123; return books &#125; func saveBooks() &#123; let fileName = &quot;\(LibraryCacheDirectory)/albums.bin&quot; let url = URL(fileURLWithPath: fileName) let bookDicts = books.map &#123; (book) -&gt; [String:Any] in book.toDictionary() &#125; let data = try? JSONSerialization.data(withJSONObject: bookDicts, options: .prettyPrinted) try? data?.write(to: url) &#125; func deleteBookAt(index: Int) &#123; if index &gt;= books.count &#123; print(&quot;数组越界，没有此绘本书&quot;) return &#125; books.remove(at: index) &#125;&#125; 感兴趣的可以在github上下载完整代码大家相互交流，整个项目只是我从实际项目中摘取出来的一个页面来讲解，而整个iOS设计模式的内容肯定址这么点内容，后续有时间我应该会更新代码讲解其他的设计模式。我的参考内容有： 图灵程序设计丛书Objective-C编程之道 iOS设计模式解析 raywenderlich官网文章iOS Design Patterns]]></content>
      <tags>
        <tag>ios 设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift构建通用版本Framework以及Framework的使用及其注意事项]]></title>
    <url>%2F2016%2F12%2F26%2F2016-12-26%2F</url>
    <content type="text"><![CDATA[前段时间公司app中有个BookRoom模块，也就是绘本阅读的模块需要重新做，并且封装成framework的形式进行（fcs项目已经很大，很冗余，每次Xcode编译项目都需要大量的时间，至少有5分钟），所以使用swift构建的framework遇到的问题坑我基本上都遇到过。于是想把整个过程记录下来，肯定有人和我一样遇到类似的问题，以便下次遇到可以快速解决； 新建Framework项目 新建项目选择Cocoa Touch Framework项目，取名为BookRoomKit，选择Swift语言 然后新建一个BookRoomManager单例类用来传值设置，并且需要申明为public，这样我们才能够在其他项目上使用我们提供的framwork的代码； 编译framework；我这里以真机发布版本framework的为例。首先使用Product-&gt;Scheme-&gt;Edit Scheme 打开如下界面，设置为Release环境，然后按照下图选择，第1步代表真机运行，第2步运行，第3步代表编译成功的BookRoomKit.framework；选中BookRoomKit.framework，右击Show inFinder，会显示编译好的framework在finder中的位置，如下图： 接下来我们新建一个壳工程，也就是测试工程，用来使用BookRoomKit.framework；并且命名为BookRoomDemo，如下图：将BookRoomKit.framework拖入项目中，勾选下面三项，然后点击Finish编写代码前，记得将壳工程切换为release环境，然后真机运行，因为编译的framework必须与壳工程运行的环境一致才能够运行成功。运行之后你会发现，程序运行不起来，奔溃的错误信息是： 123dyld: Library not loaded: @rpath/BookRoomKit.framework/BookRoomKit Referenced from: /var/containers/Bundle/Application/C3208286-60C0-456D-B512-C26FB1E6A254/BookRoomDemo.app/BookRoomDemo Reason: image not found 这里就涉及一个问题，那就是我之前的一步操作是直接从Finder中将framework拖拽进壳工程项目的，这样操作默认会将framework放置在Linked Frameworks and Libraries下面，如下图；第一：Embedded Binaries和Linked Frameworks and Libraries是有区别，具体区别看这篇文章What is the difference between Embedded Binaries and Linked Frameworks；第三：从ios8开始，苹果官方支持我们构建的dynamic framework，我们构建的BookRoomKit.framework就是dynamic frameworks，这种类型的framework它需要签名code-signed以及嵌入到我们的app，否则我们真机运行时就会奔溃Embedded Binaries with iOS Framework，还有一个问题就是，我们构建的BooRoomKit.framework往往需要使用第三方的网络请求框架，JSON解析框架等等，这些都因为代码签名的问题都得在壳工程中添加说了这么多，解决方案就是：选中Linked Frameworks and Libraries下面的BookRoomKit.framework点击删除，然后将左侧导航栏的framewotk拖拽到Embedded Binaries下面，这时Linked Frameworks and Libraries默认也会有，如下图：再次运行，你会发现运行成功，而且打印了hello bookroom Framework合并 使用lipo -info查看framework支持的cpu架构，分别对应真机版本和模拟器版本的framework信息 使用lipo -create指令将模拟器和真机的framework合并成通用版本具体操作如下：首先，切换到/BookRoomKit/Build/Products；然后执行lipo -create -output [name] [path1] [path2]这条命令；执行完成后在Products目录下生成一个BookRoomKit文件。然后将上图红圈的文件复制到Release-iphoneos中去覆盖原来的版本，最后将Release-iphonesimulator中的框架文件里的/Modules/BookRoomKit.swiftmodule里的文件复制到Release-iphoneos对应的文件夹下。这样我们就得到了一个通用的的框架。最后用这个framework替换掉测试工程的framewotk就可以在真机和模拟器运行了 测试framework专用为了便于测试工程使用framework，我这里教大家把两个项目放到一个Xcode里面打开，也不用Xcode打开两个项目，这样便于测试使用，也不用来回在framework工程和壳工程之间切换。操作如下：关闭BookRoomKit项目，打开BookRoomDemo项目，将之前的操作取消回退，删除集成进来的Book Room.framework。然后将BookRoomKit.xcodeproj拖拽进BookRoomDemo项目中，编译BookRoomKit，如下图：然后将编译好的framework拖拽进BookRoomDemo中的Embedded Binaries，如下图通过上面的操作你就可以方便的测试framework编写的代码，不用每次都编译构建framework，当你运行BookRoomDemo的时候你就能够使用framework暴露出来的方法调用。 Framework中使用image，xib，storyboard，font等资源文件 image, xib,storyboard都是需要传递相应的bundle。而我看到网上一些旧的教程都很繁琐，还要建立什么resources.bundle之类的。经过我的实践，我这种方法更为简单。1let bundle = Bundle(identifier: &quot;xcqromance.BookRoomKit&quot;) // framework的bundle ID storyboard的加载，xib类似123let sb = UIStoryboard(name: &quot;BookHome&quot;, bundle: bundle)let vc = sb.instantiateViewController(withIdentifier: &quot;BookViewController&quot;) as! BookViewControllerviewController.navigationController?.pushViewController(vc, animated: true) image的加载12let image = UIImage(named: &quot;bookroom_down_bg_blue&quot;, in: bundle, compatibleWith: nil)let imageView = UIImageView(image: image) font的加载则是比较麻烦，得先注册，才能使用！所以我写了个OC的NSObject分类 1234567891011121314151617+ (UIFont *) loadMyCustomFont:(NSString *)name size: (CGFloat)size type: (NSString *)type &#123; NSString *fontPath = [[NSBundle bundleWithIdentifier:@&quot;xcqromance.BookRoomKit&quot;] pathForResource:name ofType:type]; NSData *inData = [NSData dataWithContentsOfFile:fontPath]; CFErrorRef error; CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)inData); CGFontRef font = CGFontCreateWithDataProvider(provider); if (! CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123; CFStringRef errorDescription = CFErrorCopyDescription(error); NSLog(@&quot;Failed to load font: %@,%@&quot;, errorDescription,name); CFRelease(errorDescription); &#125; CFRelease(font); CFRelease(provider); NSString *fontName = (__bridge NSString *)CGFontCopyPostScriptName(font); UIFont* uifont = [UIFont fontWithName:fontName size:size]; return uifont;&#125; 然后在单例模初始化的时候进行注册。使用这个字体的方法和平时的一样，将fontName传递下就可以了 12345let label = UILabel()label.text = &quot;hello word&quot;label.sizeToFit()label.center = view.centerlabel.font = UIFont(name: &quot;Kreon-Bold&quot;, size: 17) Github上面下载BookRoomDemo ———————2017.04.10更新———————每次使用终端lipo -create创建通用版本很繁琐、低效，于是想到了将这个过程脚本化； 使用脚本一键构建通用版本的framework(真机、模拟器通吃的版本)步骤如下： build active architecture only设置为No 新建一个target，用来构建通用版本framework选择Cross-platform-&gt;other-&gt;Aggregate-&gt;Next命名为univeralBuilder，新建一个New Run Script Phase在shell里面添加以下内容，注意将第九行的FRAMEWORK_NAME改为自己framework的名字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Merge Script# 1# Set bash script to exit immediately if any commands fail.set -e# 2# Setup some constants for use later on.FRAMEWORK_NAME=&quot;Your framework name&quot; # 3# If remnants from a previous build exist, delete them.if [ -d &quot;$&#123;SRCROOT&#125;/build&quot; ]; thenrm -rf &quot;$&#123;SRCROOT&#125;/build&quot;fi# 4# Build the framework for device and for simulator (using# all needed architectures).xcodebuild -target &quot;$&#123;FRAMEWORK_NAME&#125;&quot; -configuration Release -arch arm64 -arch armv7 -arch armv7s only_active_arch=no defines_module=yes -sdk &quot;iphoneos&quot;xcodebuild -target &quot;$&#123;FRAMEWORK_NAME&#125;&quot; -configuration Release -arch x86_64 -arch i386 only_active_arch=no defines_module=yes -sdk &quot;iphonesimulator&quot;# 5# Remove .framework file if exists on Desktop from previous run.if [ -d &quot;$&#123;HOME&#125;/Desktop/$&#123;FRAMEWORK_NAME&#125;.framework&quot; ]; thenrm -rf &quot;$&#123;HOME&#125;/Desktop/$&#123;FRAMEWORK_NAME&#125;.framework&quot;fi# 6# Copy the device version of framework to Desktop.cp -r &quot;$&#123;SRCROOT&#125;/build/Release-iphoneos/$&#123;FRAMEWORK_NAME&#125;.framework&quot; &quot;$&#123;HOME&#125;/Desktop/$&#123;FRAMEWORK_NAME&#125;.framework&quot;# 7# Replace the framework executable within the framework with# a new version created by merging the device and simulator# frameworks&apos; executables with lipo.lipo -create -output &quot;$&#123;HOME&#125;/Desktop/$&#123;FRAMEWORK_NAME&#125;.framework/$&#123;FRAMEWORK_NAME&#125;&quot; &quot;$&#123;SRCROOT&#125;/build/Release-iphoneos/$&#123;FRAMEWORK_NAME&#125;.framework/$&#123;FRAMEWORK_NAME&#125;&quot; &quot;$&#123;SRCROOT&#125;/build/Release-iphonesimulator/$&#123;FRAMEWORK_NAME&#125;.framework/$&#123;FRAMEWORK_NAME&#125;&quot;# 8# Copy the Swift module mappings for the simulator into the# framework. The device mappings already exist from step 6.cp -r &quot;$&#123;SRCROOT&#125;/build/Release-iphonesimulator/$&#123;FRAMEWORK_NAME&#125;.framework/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/&quot; &quot;$&#123;HOME&#125;/Desktop/$&#123;FRAMEWORK_NAME&#125;.framework/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule&quot;# 9# Delete the most recent build.if [ -d &quot;$&#123;SRCROOT&#125;/build&quot; ]; thenrm -rf &quot;$&#123;SRCROOT&#125;/build&quot;fi 3.最后一步：选择Aggregate target和Simulator然后build，你会看到桌面由构建好通用版本的framework。参考资料：http://arsenkin.com/ios-universal-framework.html 2017.11.07添加 Framework依赖第三方库有人在下面提问，如果我新建的framework还依赖第三方库怎么解决？而这也是一个很正常的需求。比如我的BookRoomKit.framework有一个绘本zip包解压的功能，此时我有两种解决方案，第一将ZipArchive的代码拖入到我的framework中，还有一种是ZipArchive.framework引入到我的framework中。明显我们会选择第二种方式，一旦有更新直接替换新的的framework就行。而第二种方式又有两种方法引入：第一：在壳工程中使用pods、carhtage第三方库管理工具来添加；第二：直接将依赖的framework拖入壳工程。其实这两种方式的本质都是一样的，都有一个很关键的点就是Framework 的Build Settings中设置好依赖的第三方库的Framework Search Paths，同时在Build Phases的Link Binary With Binaries添加依赖的第三方库，下面我就以第二种方法直接将依赖的第三方库拖入壳工程进行配置为例。 将下载好的ZipArchive.framework拖入壳工程，记得勾选Copy items if needed,此时你在壳工程就已经能够使用这个库了，这是因为你拖入第三库ZipArchive时Xcode已经给你配置好Framework Search Paths，你可以在壳工程的builds settings搜索到。如下图：但是你此时在壳工程中使用ZipArchive.framework，运行起来是会crash的，奔溃信息和前文一张名为奔溃信息日志的图片是一样的，123dyld: Library not loaded: @rpath/ZipArchive.framework/ZipArchive Referenced from: /var/containers/Bundle/Application/74F5D1D3-D6B5-4C68-9629-9CAF6C16F133/BookRoomDemo.app/BookRoomDemo Reason: image not found 所以解决方案也就是一样的，在EmbeddedBinaies中添加ZipArchive.framework。 设置BookRoomKit.xcodeproj的framework Search Paths路径务必填写正确，我写的相对路径：$(PROJECT_DIR)/../BookRoomDemo/BookRoomDemo BookRoomKit.xcodeproj的Link Binary With Binaries添加ZipArchive.framework，选在Add Other，添加进来即可。接下来你就可以在BookroomKit使用ZipArchive了，具体代码你可以在BookRoomDemo下载。]]></content>
      <tags>
        <tag>swift framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2016年个人总结]]></title>
    <url>%2F2016%2F12%2F17%2F2016-12-17%2F</url>
    <content type="text"><![CDATA[转眼2016还剩不到半个月的时间，想着年初简书第一篇文章写的2016年计划以及立下的目标，现在看了看，真是差了老远！为了生活的苟且，斗志也被生活慢慢消磨！甚至把时间消耗在每天无所事事的刷刷朋友圈以及微博的八卦上面（我粗略统计了下自己花费在这上面的时间每天至少两个小时）。安逸的生活过惯了！真的就没有当初斗志和激情，对编程也没有了之前的热爱！于此同时，我也有些迷茫，我一直在思考我的一生该怎么度过？我这么努力工作的的意义是什么！我也一直希望我成功的速度，比父母老去的要快。外面的世界很精彩，我一直想去体验！外面的美食很好吃，我想去尝尝，以及父母家人还没有来得及尽孝报恩！我终将一直在寻求答案的路途中。 在此记录自己2016一年中对工作、生活以及家人的所思所想，见证自己的成长，体验到的人生的酸甜苦辣，以此共勉： 工作作为一个程序员，工作就是整天对着电脑敲敲代码，朝十晚六（不过这一般都很难做到），一般是更晚，项目紧的时候周末加加班是在正常不过的了。平时开开会讨论讨论技术，对对进度，工作闲余和同事们聊聊热点新闻、八卦！晚上回家，玩玩游戏，看看视频！写写文章。这就是程序员的一天生活！我五月底从上家公司辞职，进入了现在的公司。其实那时我挺舍不得的，熟悉的工作环境，熟悉的同事朋友，更重要的是离住的地方近，自己骑自行车10多分钟就到；有的人还经常联系，有的人就随着时间慢慢联系就少了。但是人往高处走，在一个公司呆久了，就不得不考虑自己的发展及未来，以及当时的互联网形势不容乐观。过完年回来我就知道我该走了，毕竟知道自己继续在这呆着已经没有什么发展了也没有学习以及提升的空间了！一旦自己有了清晰的定位之后，我就立马着手简历，应聘职位，不到一周我就拿到面试三家公司，其中两家给了offer！并且选择了我熟悉的，更认可教育公司也就是现在的工作的公司，而非当时火的不行的直播互联网公司！我知道，这就像15年的o2o一样，到年底洗牌的时候一大批做直播肯定会死！现在回头看，确实是明智的选择。进入新的公司，新的环境，一切都很好！我也很快的融入了新的集体，队伍也越来越庞大，做的产品也跟着计划在部署。我需要做的，能够做的是，高效高质的完成自己的工作，不拖团队的后腿，跟着团队走！尽管工作日晚上都得加会班，但是疲惫的心中确实会有一种喜悦感，成就感，自己努力、整个团队努力完成的项目逐渐得到用户的使用和认可。公司的福利和氛围还是非常好的，加班的水果，零食每天都有，零食有大家都爱吃的卫龙牌辣条，鸡翅，鸡爪等等；好多人来了不久，就发现比自己刚公司时胖了好多。公司加班晚餐也很丰盛，几乎一周一次的那个板面是我们很多人所喜爱的，感觉比外面餐馆的还正宗。我们男同胞们在晚餐前后还会来几局桌上足球，这也是一天繁重的工作中唯一的放松休闲的方式。公司9月份还组织了一次丰宁坝上草原的团建活动，看到他们发的图片就知道玩的很嗨。我其实很想去的，当初投票去哪里玩的时候，我就极力推荐去草原，可当时我奶奶突然病重，我就请假回家看奶奶了。 下面是在公司随机拍摄的点滴： 生活网上常有人带讽刺意味的说程序员：人傻，钱多，死的早！但我很不喜欢这样的标签，每个人都有自己的活法，既然选择了这条道，那就冒着头皮也得走下去。不可否认，今年关于程序员猝死的消息还不少，而原因无非就是高强度的工作，连续的加班。可能我也还没真正体验过那种提倡加班文化的公司，如BAT这些互联网大佬公司，所以不知道这究竟是怎样一个强度，当然我也一直想去体验一番。但我在这想说的是：怪自己罗！自己的生命都不珍惜，那能怨谁。身体是革命的本钱！如果公司强制加班，而你有感觉自己扛不住，那可以辞职啊！据说年初才被挖进滴滴的YYKit的作者前段时间从滴滴辞职，原因就是加班。每个人都有自己选择的权利！而我的选择就是工作时候好好工作，周末时间好好生活，好好放松，好好锻炼身体。我大学四年就有坚持跑步的习惯，晚上有时间就会去操场跑几圈；空闲时间还经常会去打篮球(尽管技术可能不怎样，但开心就好，也经常和几个哥们去球场一起打分组)。和几个哥们来北京工作后，我也坚持跑步（经常从林萃桥地铁站沿着奥林匹克公园那条路跑回家）大汗淋漓一场！那时周末也经常一起约起打篮球、爬爬北京周边的山！后来，北京周边的山都爬过了，也就很少去了。还有就是当初一起来北京的朋友好多因各种原因都回广州、深圳发展了！所以周末能约的人就少了！于是我就自己办了张健身卡，跑跑步，游游泳，练练器械，练练肌肉！还买了辆自行车，加入了骑遍天下骑行俱乐部，认识了很多朋友，俱乐部经常组织骑行活动！也经常跟着俱乐部骑行，去了草原天路，野三坡！还和一个哥们骑行去了天津，那时正好节假日，我的车中途又爆胎，耽误了点时间，不然也不至于晚上才到那里！由于没有提前预定房间，那时真的房间爆满，出来游的人真多，没有多余的房间，我们当时骑遍了天津的酒店都没有房间了，那时感到真的很绝望，晚上又累又饿！最后在一家大众浴池的大堂入宿了一晚，那条件实在是差，因为很多人也没找到房间，都住找到来了，所以什么人都有，看视频放外音的，睡觉打呼的，后半夜还有两人因为床铺打架的，我实在受不了，一整晚都没睡好，第二天骑到香河时实在是不骑不动了！只好叫了辆面的，送到了东五环！到达已到晚上，手机也没电了，没有导航；幸亏帝都好心人多，借用了下手机导航了下，以及向一位大爷问了路，最好才回到家！通过这事我都长了个心眼，外出远行去一些热门景点节假日期间必须得事先预定房间，否则就只能露宿街头，还有就是手机出门前充满电，以及带一块备用移动电源。有时工作烦躁时我还会下班回家去刷长安街，从五棵松到国贸，再原路返回每次骑行经过天安门的感觉都不一样！一场大汗淋漓之后，心中顿时轻松许多！我还骑行上下班过一段时间，从西四环到东北三环20来公里一个多小时，可惜前段时间我的爱车在公司楼下被偷了，所以只暂时只能乖乖坐地铁上下班了，明年开春准备买一辆公路自行车！ 下面是我骑行的拍的一些照片： 家人一个人来北京打拼，远离父母，一年也就回家两三次，最大的愿望是家人身体健康，远离疾病！但是发生的两件事让我很艰难，痛苦！一是上半年父亲汽车追尾，面包车报废，庆幸的是父亲并没什么大碍，另一件是奶奶去世，则让我至今都没有缓过神来，我现在都有些不相信奶奶就这样去世了，就这样离我而去，甚至不时的在某个深夜从梦中惊醒时都会痛哭流泪。这一切都来得太突然，而我却是在电话里听到这个噩耗，我以为平时这么健朗的奶奶肯定没什么大毛病，我以为国庆我回家见奶奶还是会使那个过年我回北京工作时候在我耳边唠叨这唠叨那的那个奶奶。然而这一切将无法实现，我也没能见到奶奶最后一面！只听姐姐说，奶奶走前眼角流下了一滴泪！我不知道这一滴眼泪代表着什么。但我知道了，尽孝得趁早。知道了离家之后才知道恋家，也真的只有长大之后，自己开始计算生活的时候才知道，父母为了我付出了多少。我从医生那里得知奶奶时因为蛛网膜下腔出血压迫脑部神经导致坏死而不能说话和病重，直至最后去世，从家里邻居得知奶奶出现状况那天早晨都还去了集市上卖点自己种的小菜，奶奶这一辈子都很勤俭节约，我从记事开始就是跟着奶奶过，父亲因为在家做养猪生意亏本8万多（那是在2000年左右，对于一个农村家庭来说，这可是一笔巨款）被迫南下打工，于是我就一直跟着奶奶，所以和奶奶的感情非常深刻，她经常和我讲她小时候是多么的艰苦，受当时重男轻女的观念的影响，她也没有读过书，也不认识字，我曾想教她学，但真的太费力了，于是也没有学会；还教育我不要浪费粮食（这也让我至今吃饭，碗里的米饭都基本不会剩余，吃多少，打多少的习惯），还说现在的社会怎么怎么好，要我珍惜现在的美好生活，做人也得行得正坐得端，她很喜欢看毛主席相关的电影，家中至今保留关于毛泽东DVD影片都快有上百部了，所以我也经常跟着奶奶一起看，但是她经常将一部电视剧看了一遍又一遍，有时回到家她还经常和我谈论这些剧情，我至今记得有一次回家我放学回家看她在看《毛岸英》，情节刚好是毛岸英牺牲了，她就在那感慨这么好的一个孩子怎么就没了，还和我说毛主席让他儿子上前线是多么多么伟大，叫我要像毛岸英学习。。。他最惋惜毛岸英，而我却一般会受不了她的唠叨直接走开，就去会玩自己的。现在回想起来这些是那么的熟悉，却又是那么的遥远；我以后回家再也无法听到奶奶在我耳边的唠叨。奶奶的去世我还知道了我们永远不知道下一刻会发生什么，我们也永远不知道明天和意外哪一个先来。我们唯一能做的，只是好好珍惜活着的每一分钟，善待与我们相遇的每一个人。 面对奶奶的疾病，我感到了无能为力！感觉到人类的渺小、生命的渺小！]]></content>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动打包上传实践-企业账号APP上传到自己服务器]]></title>
    <url>%2F2016%2F10%2F17%2F2016-10-17%2F</url>
    <content type="text"><![CDATA[公司使用企业账号发布app到自己服务器，每天必须发布一个app包，几乎每天在打包上面就得至少半个钟头，而每天下午都得开会30分钟，于是就想充分利用这时间，在开会前在输入终端命令，执行脚本文件实现自动打包，并且上传到自己服务器。这样开完会就已经自动打包完成。早点下班回家！本文是参考：iOS自动打包并发布脚本的实践 使用苹果自带的工具xcodebuild和xcrun打包签名 打开Mac终端，输入命令 man xcodebuild ,man xcrun查看使用方法。 在项目的根目录输入以下命令：xcodebuild -workspace leapParent.xcworkspace -scheme leapParent-configuration Release，我使用的是cocoapods管理的项目所以使用第一张图的第三种方式build，成功之后如下：此时在./Build/Release-iphoneos文件夹下会有leapParent的文件。紧接着输入：xcrun -sdk iphoneos -v PackageApplication /Users/romance/Desktop/CQCoder/CloudClassroom_iOS/Build/Products/Release-iphoneos/leapParent.app -o ~/Desktop/leapParent.ipa；其中-o ~/Desktop/leapParent.ipa:代表项目打包输出的路径，/Users/romance/Desktop/CQCoder/CloudClassroom_iOS/Build/Products/Release-iphoneos/leapParent.app这个是上一步骤xcodebuild成功之后.app的绝对路径 使用python脚本实现的自动打包（原理就是将2的内容用python写好，然后传入参数，执行脚本）将autobuild.py，放入项目的根目录，然后执行python ./autobuild.py -w leapParent.xcworkspace -s leapParent -o ~/Desktop/leapParent.ipa命令，此时可能报错：ImportError: No module named requests此时输入以下命令就可以解决问题sudo easy_install -U requests其中autobuild.py有这几项需要配置下：1234CODE_SIGN_IDENTITY = &quot;iPhone Distribution: xxxxxxxx Co. Ltd (xxxxxxx9A)&quot;PROVISIONING_PROFILE = &quot;xxxxxxxxxx-xxxxx-xxxxx-xxxx-xxxxxxxxxxxx&quot;CONFIGURATION = &quot;Release&quot;SDK = &quot;iphoneos&quot; 其中CODE_SIGN_IDENTITY获取方式：PROVISIONING_PROFILE获取方式： 至此，就大功告成了！但还没做上传到自己服务器，但这个也容易叫后台人员添加一个接口，配置autobuild.py文件就可以了。 添加app打包完成后自动上传到upyun服务器这步骤相对简单，参考upyun的Python SDK官方文档将上传方法添加到脚本文件就可以了（温馨提示下：python文件不要用xcode打开编辑，使用sublime就行，因为tab键为4个空格，不符合python语法，执行脚本文件会出错）我使用的是断点续传：]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS的使用Swift，NSOperation实现的倒计时]]></title>
    <url>%2F2016%2F09%2F22%2F2016-09-22%2F</url>
    <content type="text"><![CDATA[前段时间，公司项目有个需求要求实现任务倒计时，头疼死我了，折腾了我老半天，先看最终的实现效果，如下图。当时的需求有两点要求： 要求在当前任务关卡实现倒计时计算； 要求在弹出来的tips页面同时也进行倒计时。 一想到倒计时，我们可能想到的解决方案有三种；NStimer、GCD、NSOperation NSTimer实现倒计时NSTimer实现计时需要注意，他默认是在runloop中的NSDefaultRunLoopMode计时，在这个模式下面，有滑动事件，计时将失效，此时我们需要在将timer添加到runloop中的NSRunLoopCommonModes,这样就不会有任何影响123let animationTimer = NSTimer.scheduledTimerWithTimeInterval(10, target: self, selector: #selector(WeeklyMissionViewController.runanimation), userInfo: nil, repeats: true)NSRunLoop.mainRunLoop().addTimer(animationTimer!, forMode: NSRunLoopCommonModes)animationTimer!.fire() GCD实现倒计时GCD实现计时需要注意的是let _timer: dispatch_source_t必须存储为全局变量timer = _timer123456789101112131415161718192021222324252627282930313233343536373839private func setGCDTimer(weeklyMission: MissionList, type: Int) &#123; // 计算倒计时 let nowDate = NSDate() let nowUnix = nowDate.timeIntervalSince1970 let count = (weeklyMission.createdAt)! + 24 * 3600 - Int(nowUnix) var _timeout: Int = count let _queue: dispatch_queue_t = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) let _timer: dispatch_source_t = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, _queue) timer = _timer // 每秒执行 dispatch_source_set_timer(_timer, dispatch_walltime(nil, 0), 1 * NSEC_PER_SEC, 0) printLog("----_timer-----") dispatch_source_set_event_handler(_timer) &#123; () -&gt; Void in if _timeout &lt;= 0 &#123; // 倒计时结束 dispatch_source_cancel(_timer) dispatch_async(dispatch_get_main_queue(), &#123; [unowned self] () -&gt; Void in // 如需更新UI 代码请写在这里 &#125;) &#125; else &#123; print("cell:\(weeklyMission.mission)---\(_timeout)") _timeout -= 1 let hours = _timeout / 3600 let hoursSec = hours * 3600 let minutes = (_timeout - hoursSec) / 60 let seconds = _timeout - hoursSec - minutes * 60 dispatch_async(dispatch_get_main_queue(), &#123; [unowned self] in let timeText = "\(String(format: "%.2d",hours)):\(String(format: "%.2d",minutes)):\(String(format: "%.2d",seconds))" // 如需更新UI 代码请写在这里 &#125;) &#125; &#125; dispatch_resume(_timer) &#125; NSOperation实现倒计时以上两种实现的计时，有个很明显的缺点就是，不可控！他们二者开启一个计时器之后，没法方便的控制他停止，继续；但是NSOperation不同，他有cancel方法，我们可以拿到对应的operation，然后操作他，可控性好。主要代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130//// TimeCountDownManager.swift// leapParent//// Created by romance on 16/9/19.// Copyright © 2016年 Firstleap. All rights reserved.//import UIKit/// 计时中回调typealias TimeCountingDownTaskBlock = (timeInterval: NSTimeInterval) -&gt; Void// 计时结束后回调typealias TimeFinishedBlock = (timeInterval: NSTimeInterval) -&gt; Voidprivate var shareInstance = TimeCountDownManager()final class TimeCountDownManager: NSObject &#123; // 单利 class var sharedInstance : TimeCountDownManager &#123; return shareInstance &#125; var pool: NSOperationQueue override init() &#123; pool = NSOperationQueue() super.init() &#125; /** * 开始倒计时，如果倒计时管理器里具有相同的key，则直接开始回调。 * * @param Key 任务key，用于标示唯一性 * @param timeInterval 倒计时总时间， * @param countingDown 倒计时时，会多次回调，提供当前秒数 * @param finished 倒计时结束时调用，提供当前秒数，值恒为 0 */ func scheduledCountDownWith(key: String, timeInteval: NSTimeInterval, countingDown:TimeCountingDownTaskBlock?,finished:TimeCountingDownTaskBlock?) &#123; var task: TimeCountDownTask? if coundownTaskExistWith(key, task: &amp;task) &#123; task?.countingDownBlcok = countingDown task?.finishedBlcok = finished if countingDown != nil &#123; countingDown!(timeInterval: (task?.leftTimeInterval) ?? 60) &#125; &#125; else &#123; task = TimeCountDownTask() task?.leftTimeInterval = timeInteval task?.countingDownBlcok = countingDown task?.finishedBlcok = finished task?.name = key pool.addOperation(task!) &#125; &#125; /** * 查询倒计时任务是否存在 * * @param akey 任务key * @param task 任务 * @return YES - 存在， NO - 不存在 */ func coundownTaskExistWith(key: String,inout task: TimeCountDownTask? ) -&gt; Bool &#123; var taskExits = false for (_, obj) in pool.operations.enumerate() &#123; let temptask = obj as! TimeCountDownTask if temptask.name == key &#123; task = temptask taskExits = true// print("coundownTaskExistWith#####\(temptask.leftTimeInterval)") break &#125; &#125; return taskExits &#125; /** * 取消所有倒计时任务 */ func cancelAllTask() &#123; pool.cancelAllOperations() &#125; /** * 挂起所有倒计时任务 */ private func suspendAllTask() &#123; pool.suspended = true &#125;&#125;final class TimeCountDownTask: NSOperation &#123; var leftTimeInterval: NSTimeInterval = 0 var countingDownBlcok: TimeCountingDownTaskBlock? var finishedBlcok: TimeFinishedBlock? override func main() &#123; if self.cancelled &#123; return &#125; while leftTimeInterval &gt; 0 &#123; print("leftTimeInterval----\(leftTimeInterval)") if self.cancelled &#123; return &#125; leftTimeInterval -= 1 dispatch_async(dispatch_get_main_queue(), &#123; if self.countingDownBlcok != nil &#123; self.countingDownBlcok!(timeInterval: self.leftTimeInterval) &#125; &#125;) NSThread.sleepForTimeInterval(1) &#125; dispatch_async(dispatch_get_main_queue()) &#123; if self.cancelled &#123; return &#125; if self.finishedBlcok != nil &#123; self.finishedBlcok!(timeInterval: 0) &#125; &#125; &#125;&#125; 稍微解析下以上代码，TimeCountDownManager是定时器管理类，是个单利，可以管理app中所有需要倒计时的task，TimeCountDownTask是具体的用来处理倒计时的NSOperation子类，大家还可以在我的基础上进行完善，比如cancel具体taskIdentifier的task，suspended具体的task，等等！ 整个demo代码的GitHub地址]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift实现的单词高亮]]></title>
    <url>%2F2016%2F08%2F30%2F2016-08-30%2F</url>
    <content type="text"><![CDATA[公司做的一款教育App中，有个BookReading模块是孩子用来学习英语，里面又有一个子模块Listen用来播放句子，产品的需求是要求单词跟随着句子的播放而高亮，效果如下；GitHubDemo地址下载，这种需求之前没做过，网上搜索的也没有资料（有的也是歌词的高亮），所以花费了点时间，现在趁闲暇时间写了个小小的demo，和大家分享，整个代码写的比较基础，有相似需求的可以借鉴，不懂的地方欢迎相互交流 整体思路 分析服务器提供的json数据格式，demo中即为lrc.json，知道每个单词都有读的对应的开始时间其中我定义了一个var wordRanges = [NSRange]()，用来存储每个单词的Range，用来匹配相应单词的高亮。 123456let textStr: NSString = section!.text self.wordRanges.removeAll() // 在下一次添加之前，得先删除之前的 weak var weakSelf = self textStr.enumerateSubstringsInRange(NSMakeRange(0, textStr.length), options: .ByWords) &#123; (substring, substringRange, enclosingRange, bb) in weakSelf!.wordRanges.append(substringRange) &#125; 使用CADisplayLink添加到mainRunloop中，来实现不停的重绘UI工作，相比于定时器精确度更高 123456private func setupTimer() &#123; displayLink = CADisplayLink(target: self, selector: #selector(BookCollectionViewController.displayWord)) displayLink?.addToRunLoop(NSRunLoop.mainRunLoop(), forMode: NSDefaultRunLoopMode) // mode 为 NSRunLoopCommonModes // 调用的频率 默认为值1，代表60Hz，即每秒刷新60次，调用每秒 displayWord() 60次，这里设置为10，代表6Hz displayLink?.frameInterval = 10 &#125; 代码实现12345678910111213141516171819202122232425262728func displayWord() &#123; let cell = self.collectionView.visibleCells().first as! BookCollectionViewCell let indexPath = collectionView.indexPathForCell(cell) guard let page = model?.pages[(indexPath?.item)!] else &#123;return&#125; guard let section = page.sections.first else &#123;return&#125; var i = 0 while true &#123; let curTime = audioPlayer?.currentTime ?? 0 // 播放声音的的时间，ms guard (wordRanges.first != nil) else &#123;break&#125; let word = section.words[i] let curRange = wordRanges[i] if Int(curTime * 1000) &gt;= Int(word.cueStartMs) &#123; // 拿当前播放的声音时间与json每个单词的开始读取时间相比， attributeStr?.addAttributes([NSForegroundColorAttributeName: UIColor.whiteColor()], range: NSMakeRange(0, attributeStr!.length)) attributeStr?.addAttributes([NSForegroundColorAttributeName: UIColor.redColor()], range: curRange) cell.content.attributedText = attributeStr &#125; i += 1 if i &gt;= wordRanges.count || i &gt;= section.words.count &#123; break &#125; &#125; &#125;]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《联盟》奇点系列读后感]]></title>
    <url>%2F2016%2F06%2F21%2F2016-06-21%2F</url>
    <content type="text"><![CDATA[花了一个周末将《联盟》这本书籍读完了，记录一下自己的读后感！在互联网的时代，终身雇佣制缺少灵活性，不再适应网络时代；于是出现了自由雇佣制年代，也就是我们正所经历的时代。在联盟这一新型的雇佣关系中，雇主与员工相互信任并且相互投资，一起打造双赢的工作模式 《联盟》作者是里德.霍夫曼全球最大职业社交网站LinkedIn的创始人之一和执行总裁，硅谷风险投资公司Greylock合伙人。 本书总共八章一、互联网时代的的雇佣关系—通过简历联盟重建信任与忠诚二、任期制—设计渐进性承诺三、任期中的协调-协调员工与公司的目标与价值观四、执行转变期计划五、利用员工人脉获取情报—让世界为我所用六、执行人脉情报计划七、投资公司同事联络网—终身联盟的互惠关系八、发挥同事联络网的功效 我总结本书大概下面几点内容 先解释几个关键词： 任期制 联盟适用的对象是处于转变期的员工，轮转期的员工具有高度的流动性，基础器的员工已经十分稳定。处于转变期的员工刚好介于两者之间，他们对自己的能力有较为清晰的认识，同时具备一定的职业规划，能在自身能力和公司的需求上寻找平衡。 同事联络网 建立联盟的的两种的做法 任期中的协调-协调员工和公司的目标和价值观 执行转变期计划-通过开诚布公的双向对话建立信任，打造合适的任期计划 总结 终身雇佣时代已经过去，联盟的时代正在来临。通过雇主与雇员之间开诚布公的双向对话，互不信任的雇佣关系可以转变为互惠互利、互相投资的终身联盟； 打造任期制，将非终身雇佣的员工变为公的长期人脉，并且吸收员工的高效人脉情报 员工的人脉情报是新信息的来源，它会带来隐藏的数据、意外的发现和机会；公司应该鼓励员工正确运用人脉情报开展工作，并且将其带回公司； 投资公司同事联盟网络，公司可以建立与员工的终身联盟关系，双方的价值都可以大大提升，他可以提供人脉情报，推荐人才，甚至提高销售额。]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个iOS程序员的面试心得]]></title>
    <url>%2F2016%2F06%2F11%2F2016-06-11%2F</url>
    <content type="text"><![CDATA[前言前段时间经过一段长时间的纠结，终于决定离开公司另谋出路。我的上家公司是一家创业公司做教育o2o的，没有融资（也一直没有拉到融资），是一家传统的少儿教育艺术培训学校投资成立的一家互联网教育公司。大家都知道去年o2o非常火，但有一个弊端就是烧钱烧的厉害，而传统行业也想借着移动互联网这东风乘势发展壮大，他也有个弊端就是没有那些新兴的互联网公司那么有魄力，有思维，毕竟做传统行业做久了有其思维局限；后面因为资金的原因，产品出来了却一直推广不开来，尽管这个项目从最开始成立的时候我就来了，也算是元老级别的人物了，但是我一直看不到未来的发展！于是我就决定离开！另谋发展！ 言归正传，我的求职者之路 骑驴找马 招聘平台很重要（干货） 面试环节（干货） 骑驴找马说真的，我的求职我算是比较顺利的，因为我就面试了的第一家公司就直接给了offer，他是做少儿英语教育的。而我是利用上班时间去面试的，前言部分我也说过，公司产品艺学去年过年以前就基本完成了，过年回来也就改改小bug，新增小需求，学习swift、php、h5，事情比较少，自己比较闲，而且之前加班有调休没有用完，所以一旦有面试机会就可以请个半天假去面试，也就是大家熟称的骑驴找马。 在这里我不得不警告想换公司的程序员们不要辞职之后再找工作（当然你觉得你有这个能力，那也可以这么做），风险太大，我一个朋友的朋友从过年到现在4个月了都没有找到工作（在各大平台上投递简历300多份，共有面试机会20个左右，当然很大一部分原因是他整天玩游戏，根本就没有集中精力找工作，简历写的不咋样）；大家都知道去年是iOS开发的的顶峰时期，iOS移动开发人员需求量算是达到了顶峰，于是大批的毕业生和其他其行业的人员通过培训掌握iOS开发，导致供求关系的天平向公司这边倾斜，然后去年年末又是互联网寒冬，大批的互联网为公司倒闭，所以工作不好找； 招聘平台很重要我推荐boss直聘，等待周期短，直接和对方hr、CTO或者CEO聊听对话，对方看你简历不错直接就有面试机会。 2017.08.30补充：前段时间爆出的李文星之死，面试者自己需要留个心眼，毕竟别为了急着找工作而不假思索的去面试，网上有好多防骗指南，我这里也分享一个求职防骗指南 提取密码: dbbq 找工作之初，我就开始关注各大招聘信息平台，手机里面也下载了相应app比如拉钩网，boss直聘，猎聘，脉脉，智联招聘，看到上面发布的的职位还是挺多的，薪资也还行，但貌似没有去年那么好，公司的职位要求也提高了许多；我花费整整一天的时间填写好自己的详细信息，并且写好了简历；开始了我的投递简历过程，刚开始我还是很谨慎的，只是在拉勾上面投了我中意的公司；以及在猎聘上和猎头联系，以及在脉脉上和一些大公司联系！ 不管是和猎头沟通还是通过脉脉和这些BAT一样的一线的互联网公司的相关人员交流，看了我的简历都指出我的技术能力可以，但是就是教育背景不行；前两家公司都是在创业型的小公司工作，单挑项目，app不出名，比较小众，尽管能锻炼能力，但是说实在的这样的工作经历真心不好找下家，此刻我才明白，必须得去大公司镀镀金，我毕业的吉首大学，咋一听是不是以为和吉林大学有点关系，其实毛关系都没有，后者是985高校，前者只是湖南省一个很普通的2本；而且我想大多数人应该和我一样都不是名牌学校出来，这找工作就看出了差异，猎头看我不是985、211出来的，直接就说不给我推，后面我也就没在猎聘上投了；而且好多猎头是骗你简历。 而我在拉勾上投递的都是像新浪，小米，百度，京东这样的大公司，但是结果可想而知，等了将一两周的时间，人家好不容易看了我的简历，立马被标记为不合适； 所以我建议大家别用拉勾网投，对方处理你的简历时间长，你耗不起，如果你要投，也得投回复率高的公司；后面我果断换了boss直聘，你看中某个职位能够直接和对方聊听，对方看了你的微简历感觉还ok的话就会和你聊下去，否者基本上不会理你，所以在boss直聘上面的微简历一定要写好，写的详细点，自己的优势，充分展示自己，让hr能够给你面试机会； 面试环节 hr面试无非就是问一些诸如，为什么离开现公司，期望工资多少，未来有什么发展之类的！这些你就根据个人如实回答就行 技术面试（做好充足准备）现在iOS面试的也就那么些题目，所以就算你不会，那么背，你都要背下来；我推荐两个不错的链接，供大家学习；（1）iOS面试题，这里面有基础篇，UI篇，原理篇很全面；（2）招聘一个靠谱的 iOS，这里面有许多涉及底层的知识，如runtime，runloop。但是想要真正理解，还是得自己敲代码才行。我敢说，只要你把把这两个里面的问题都弄懂，一般iOS的技术面试你90%都没什么问题！ 加分点我认为这一点非常重要，程序员必须要有建立自己的技术博客，GitHub有自己的开源项目，AppStore有自己的app等等这些都能为你的面试加分。这很能在面试官面前体现你的专业性。 最后，给大家分享Easy写的程序员跳槽全攻略，对我们程序员未来的发展分析的很透彻，通过这个你能知道自己未来是要走技术大牛路线、管理路线或是自己创业！]]></content>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你快速学会Git分布式版本控制]]></title>
    <url>%2F2016%2F05%2F19%2F2016-05-19%2F</url>
    <content type="text"><![CDATA[因为使用Github，OSChina管理自己项目的时候，使用git终端命令不是特熟悉，所以特地特地把公司之前买的Git 版本控制管理(第二版)给看了一遍，再结合自己实际操作，对Git的使用和理解还是提升的不少；所以就写一篇博文来记录自己的学习Git之旅，有误之处欢迎大家指正。 Git的简单介绍 Git和SVN的对比 Git使用的快速入门 Github、OSchina的使用 对于前两部分的内容，大家可以初略看下，有个印象知道一些名词概念就好，重点还是得多练习、多操作，也就是第三部分内容需要实际操作； Git的简单介绍Git是什么？Git是一款免费、开源的分布式版本控制系统；是由Linux之父Linus开发，开发缘由自己可以上网查看下或者下载我在百度云盘分享的Git权威指南，Linus确实很牛逼，不得不佩服人家，花了一个月的时间就开发成功了！与Git对应的集中式版本控制有CVS、SVN（集中式版本库控制的集大成者）。 Git读音：有必要先说一下Git的读音，音标：[gɪt]，字母G的发音与Gives、Gift的发音一样，所以发音听起来像是“歌易特”；我之前的读法和听到很多人的读法一直都是错误的：“计易特”； Git的工作原理有必要介绍下几个名词：工作区（Working Directory）：仓库文件夹里除.git目录以外的目录；版本库（Repository）：位于工作区根目录下.git目录中，用于存储记录版本信息，.git是一个隐藏文件夹，在终端中输入这条命令defaults write com.apple.finder AppleShowAllFiles -bool true就可以显示隐藏文件（隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool false）；- 暂缓区（stage）- 分支（master）：git自动创建的第一个分支- HEAD指针：用于指向当前分支 Git的工作流程 Git和SVN的对比集中式版本控制和分布式版本控制的对比从下面两个图可以看出这二者之间的区别： 分布式下开发者可以本地提交代码，集中式必须联网才能提交； 分布式下开发者的电脑就是一个完整的版本库，拥有本地的代码仓库。Git和SVN的对比1、 速度：Git比SVN快；2、结构：Git是分布式管理，SVN是集中式管理；3、其他：Git支持本地版本控制工作，SVN必须联网才能；Git拥有更强大的分支管理；Git只会在根目录拥有一个.git，旧版本的svn会在的每个目录放一个.svn等等。 Git使用的快速入门使用git init创建初始版本库；打开GitDemo文件夹可以看到新增了个.git隐藏文件夹，所有的版本数据库数据都将存放在.git的隐藏子目录中； 使用git clone [remoteURL]从远程服务器克隆一份代码到本机；在公司中，经常是团队开发，先从服务器把项目给clone到自己电脑 使用git add [xxx]将文件添加到暂缓区我们都知道Mac 电脑的Xcode已经完美的集成了Git，如下图，当我在GitDemo中新建一个项目是勾选框将为灰色；如图：此时项目的文件有个状态为A、M和“？”（刚开始可能全是“？”当重新打开后就变为下图的状态了）此时用在终端中输入命令git status查看你的文件在工作目录与缓存的状态上图显示的红色字体表示：新添加的文件或者修改的文件在工作区没有添加到暂缓区如果此时用git add .命令将会把工作区的所有文件添加到暂缓区中； 使用git commit 把暂缓区的所有内容提交到当前分支（master分支）使用终端输入git status查看，都变为绿色了，这就表示工作区的代码已经添加到暂缓区中，可以提交到本地代码仓库了终端输入命令git commit -m&quot;初始化版本仓库&quot;，Xcode项目的各个文件右边的A和M都消失了，说明纳入版本控制成功 添加.gitignore文件(.git 同一级目录下)我之前分享的使用oschina托管自己项目第三大点有说过在GitHub下载gitignore文件，因为我的项目是Objective-C语言编写的所以我要添加的是Objective-C.gitignore，在终端中如下命令：123cp /Users/xcq/Downloads/gitignore-master/Objective-C.gitignore .gitignoregit add .gitignore git commit -m&quot;添加gitignore文件&quot; 可以看到当前目录多了一个.gitignore添加.gitignore文件步骤很重要、很重要、很重要，重要的事情说三遍；添加.gitignore文件的步骤操作最好在git init步骤之后，也就是创建初始版本库之后就在工做根目录（也就是与.git同一层及目录）下添加.gitignore文件，然后再用Xcode新建一个项目，这样做才会真正的把所有不需要纳入版本控制的文件忽略；我之前的操作正好相反，是先新建了一个CQActionView的项目，然后才添加的.gitignore文件，这样做的后果是UserInterfaceState.xcuserstate并没有忽略，每一次command + 编译都会产生用Xcode自带Git的Commit也能看到，项目没有做任何修改，但是一编译就会有一些用户缓存数据还有种情况是我们已经写好的项目需要用Git管理，然后才添加的.gitignore文件，这也会出现上述问题其中 CQActionView/CQActionView.xcodeproj/project.xcworkspace/xcuserdata/xcq.xcuserdatad/UserInterfaceState.xcuserstate 是上面第二张图红色的那个路径，直接copy过来就行；git rm --cached [xxx]会将文件从缓存区删除，但是工作目录中还存有该文件，解决方案如下：12git rm --cached CQActionView/CQActionView.xcodeproj/project.xcworkspace/xcuserdata/xcq.xcuserdatad/UserInterfaceState.xcuserstate git commit -m&quot;Removed file that shouldn&apos;t be tracked&quot; 使用git branch [xxx]创建分支，git branch查看在本地的分支，git branch -va可以查看本地+远程分支列表如图，我们新建了一个“branch1”分支。如果你在master分支做了变更并且更新提交， 然后切换到了“ branch1”分支，Git 将还原你的工作目录到你创建分支时候的样子； 工作实例：如下图，公司的远程仓库有有两个分支：master和feature_react_native。老大要求我在feature_react_native分支上进行功能开发，但是我clone到本地的代码对应的是远程的master分支，此时我就需要修改这种映射关系。如下图，通过git branch -vv查看本地分支和远程分支的跟踪关联关系：为本地的master和react_native分支都是对应远程的origin/master分支，这是导致的结果是，你完成修改代码然后push到的是远程的master分支，这是不符合要求的，通过git branch --set-upstream react_native origin/feature_react_native让本地分支react_native与远程分支origin/feature_react_native关联，这样你以后提交的代码就不会提交到远程master分支了 使用git checkout [xxx]切换分支，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录如图，我在master分支，修改了ViewController.m文件并且提交，当我们切换到“branch1”分支的时候，ViewController.m又重新回到修改前的模样 使用git checkout -b [branchname] 创建新的分支，并立即切换到它，也就是6和7步可以合并到这一步；git checkout -b develop master基于主分支创建develop分支；与此同时你打开Xcode的Sourse Control也可以看到有三个分支： git branch -d [branchname]删除本地分支，git push origin --delete [branchname]删除远程分支 使用git merge [branchname]来合并分支我在“ branch1”分支中编写了一段代码，完成了一段功能，并且想合并到master分支中，此时我需要先切换到master分支中，然后执行git merge branch1新建的本地仓库与远程仓库进行关联，在本地仓库.git文件目录下执行git remote add origin [remoteURL]，origin是远程仓库的名字。然后本地仓库的内容推送到远程仓库git push -u origin master；如果失败则执行git pull origin master [--allow-unrelated-histories]，如果提示失败信息：fatal: refusing to merge unrelated histories，则上面中括号的参数需要添加。 以下是一些其他Git命令，我就没做例子，大家可以操作练习 给git起个别名git config alias.[别名] “status” 查看历史版本git log50163165822d3141742f4d4aece0e5c222ef156egit reflog // 查看分支引用记录git 版本号是有SHA1机密算法生成的一个40位的哈希值 版本回退 12345678# 回到当前版本，放弃所有没有提交的修改git reset --hard HEAD# 回到上一个版本git reset --hard HEAD^# 回到之前第10个修订版本git reset --hard HEAD~10# 回到指定版本号的版本$ git reset --hard [版本号前七位] 添加标签（又叫添加里程碑）git tag -a v1.0 -m &#39;version 1.0&#39;，其中v1.0代表tagname，version 1.0代表标签的说明信息；git push origin v1.3:v1.3，将标签推送到远程仓库，v1.3:v1.3代表将本地v1.3推送到远程仓库的v1.3；git tag查看本地的标签；git tag -d 1.0删除本地的标签，1.0代表标签的版本；git push origin :v1.2删除远程的标签，这种情况发生在推送到远程的标签版本有错误，为了防止其他人获取到错误的标签，应该尽快的删除标签。 掌握以上的git内容，就能胜任平时90%开发的任务。最后，关于Git 分支的练习，我这有个好的练习网址：Learn Git Branching ，也是一个同事分享给我的，他的Git命令使用的溜溜的；很不错的一个练习Git分支操作的网址，大家点击进去之后可能什么内容都没有，不要急，稍等片刻就会出来。 Github、OSchina的使用从Github上clone代码，push，pull的操作大家可以下载GitHub Desktop 图形化界面进行操作，OSchina就可以使用Xcode集成的Git，大家可以添加远程仓库地址，在Preferences(common + ,)–》Account –&gt;左下角有个加号–》Add Repository；然后就可以提交到远程中了。 终于写完了，不容易啊，太困了，最后的内容写的有点粗糙啊，见谅。。。😂😂😂]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS集成百度地图实现在线建议地址查询]]></title>
    <url>%2F2016%2F05%2F08%2F2016-05-08%2F</url>
    <content type="text"><![CDATA[今天和大家分享：集成百度地图iOS SDK，实现在线建议查询地址。这是我的github源码，使用oc纯代码编写，部署版本是iOS8，大家可以下载运行代码； 配置开发环境进入百度地图开发者中心根据步骤即可实现。我是使用CocoaPods导入地图SDK（没有安装CocoaPods，可以根据这篇文章使用CocoaPods安装和使用教程），而且我也极力推荐大家使用CocoaPods来管理第三方库；我主要讲一下注意点：注意一：务必在info.plist如下配置12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; 注意二：按需引入SDK中的头文件，不要把所有的头文件包含进来，这样会导致编译时间延长，如下实现在线建议查询地址我这项目中只需要引入连个头文件即可12#import &lt;BaiduMapAPI_Search/BMKSearchComponent.h&gt; //引入检索功能所有的头文件#import &lt;BaiduMapAPI_Location/BMKLocationComponent.h&gt;//引入定位功能所有的头文件 注意三：info.plist文件记得添加另外两个key-value， 打开定位服务 123需要在info.plist文件中添加(以下二选一，两个都添加默认使用NSLocationWhenInUseUsageDescription)；NSLocationWhenInUseUsageDescription 允许在前台使用时获取GPS的描述；NSLocationAlwaysUsageDescription 允许永远可获取GPS的描述。 添加Bundle display name 代码实现先简要介绍下项目的各个类，如下图 主要介绍下LocationManager类是对开始定位和停止定位封装好的单例，主要有三个方法：123456789101112/** * 开始定位 */- (void)startLocation;/** * 停止定位 */- (void)stopLocation;/** * 判断是否授权开启定位 */- (BOOL)isAuthorizeOpenLocation; 在AppDelegate.m文件中 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // 要使用百度地图，请先启动BaiduMapManager _mapManager = [[BMKMapManager alloc]init]; BOOL ret = [_mapManager start:BMAppKey generalDelegate:self]; if (!ret) &#123; NSLog(@&quot;manager start failed!&quot;); &#125; // 程序一启动开始定位 [[LocationManager shareLocationManager] startLocation]; // 1.初始化窗口 self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; // 2.设置窗口根控制器 self.window.rootViewController = [[UINavigationController alloc] initWithRootViewController:[[SelectAddressTableViewController alloc] init]]; // 3.显示窗口 [self.window makeKeyAndVisible]; return YES;&#125; LocationManager中的startLocation方法中获取位置信息//初始化BMKLocationService 123456789101112131415 - (instancetype)init &#123; if (self = [super init]) &#123; //初始化BMKLocationService _locService = [[BMKLocationService alloc]init]; _locService.delegate = self; // 设定定位的最小更新距离(米)，更新频率。默认为kCLDistanceFilterNone _locService.distanceFilter = 100.0f; // 设定定位精度。默认为kCLLocationAccuracyBest。 _locService.desiredAccuracy = kCLLocationAccuracyNearestTenMeters; // 定位精度10m _geoSearcher = [[BMKGeoCodeSearch alloc] init]; _geoSearcher.delegate = self; &#125; return self;&#125; 123456789- (void)startLocation &#123; if ([self isAuthorizeOpenLocation]) &#123; // 已经授权定位 //启动LocationService [_locService startUserLocationService]; &#125; else &#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;定位服务未开启&quot; message:@&quot;请在设置中开启定位服务&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;去设置&quot;, nil]; [alert show]; &#125;&#125; 123456789// 判断是否授权开启定位- (BOOL)isAuthorizeOpenLocation &#123; if ([CLLocationManager locationServicesEnabled] &amp;&amp; ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedAlways || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedWhenInUse)) &#123; return YES; &#125; return NO; &#125; 在回调方法中12345//处理位置坐标更新- (void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123;&#125; 3、发起反向地理编码检索123456789101112131415161718192021222324//处理位置坐标更新- (void)didUpdateBMKUserLocation:(BMKUserLocation *)userLocation&#123;// NSLog(@&quot;didUpdateUserLocation lat %f,long %f&quot;,userLocation.location.coordinate.latitude,userLocation.location.coordinate.longitude); //发起反向地理编码检索 _geoSearcher = [[BMKGeoCodeSearch alloc] init]; _geoSearcher.delegate = self; CLLocationCoordinate2D pt = (CLLocationCoordinate2D)&#123;userLocation.location.coordinate.latitude, userLocation.location.coordinate.longitude&#125;; BMKReverseGeoCodeOption *reverseGeoCodeSearchOption = [[ BMKReverseGeoCodeOption alloc] init]; reverseGeoCodeSearchOption.reverseGeoPoint = pt; BOOL flag = [_geoSearcher reverseGeoCode:reverseGeoCodeSearchOption]; if(flag) &#123; NSLog(@&quot;反geo检索发送成功&quot;); &#125; else &#123; NSLog(@&quot;反geo检索发送失败&quot;); &#125;&#125; 接收反向地理编码的回调 123456789101112131415161718192021// 接收反向地理编码结果-(void) onGetReverseGeoCodeResult:(BMKGeoCodeSearch *)searcher result:(BMKReverseGeoCodeResult *)result errorCode:(BMKSearchErrorCode)error&#123; if (error == BMK_SEARCH_NO_ERROR) &#123; // 在此处理正常结果 NSLog(@&quot;%@--%@&quot;,result.addressDetail.city, result.address); if ([[[NSUserDefaults standardUserDefaults] valueForKey:@&quot;UserCurrentAddress&quot;] isEqualToString:result.address]) &#123; // 用户当前位置与沙河存储位置相同 // 关闭定位服务LocationService [self stopLocation]; &#125; else &#123; [[NSUserDefaults standardUserDefaults] setValue:result.addressDetail.city forKey:@&quot;UserCurrentCity&quot;]; // 将用户城市位置存储，以便后面进行设置地址时的city [[NSUserDefaults standardUserDefaults] setValue:result.address forKey:@&quot;UserCurrentAddress&quot;]; &#125; &#125; else &#123; [self startLocation]; NSLog(@&quot;抱歉，未找到结果&quot;); &#125;&#125; 具体代码实现可以github源码上面下载]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac系统U盘启动盘的制作及Mac系统的安装]]></title>
    <url>%2F2016%2F05%2F03%2F2016-05-03%2F</url>
    <content type="text"><![CDATA[人生就像卫生纸，尽量少扯；时间就像卫生纸，看着挺多，用着用着就没了 本文将分享如何制作OS X EI 10.11系统的 u盘启动盘（只能使用mac电脑制作）以及Mac系统的安装步骤。 本文包含以下内容： U盘启动盘的制作 Mac系统的安装步骤 U盘启动盘的制作先下载“ OS X EL”安装程序打开appstore，点击精选，在右上角搜索栏内输入“Capitan”，搜索到10.11.4，OS X ELCapitan最新系统，点击下载或获取安装进行下载。下载完成，弹出提示是否需要更新，请勿点击更新。关闭App Store，并且打开finder，确认“ OS X EL”安装程序是否在“应用程序”中，下图是下载好的最新系统； U盘格式化Mac OS 扩展日志式准备一个8GB的U盘，然后打开应用程序-实用工具-磁盘工具，左侧-选择U盘，然后点击右边“抹掉”选项，格式选择Mac OS 扩展日志式，磁盘名称一定要写MyVolume，然后点击抹掉。如下图所示： 使用终端命令制作安装盘抹掉U盘以后，打开应用程序-实用工具-终端：在终端中输入以下命令，直接复制粘贴即可，完成后，会提示输入管用员密码，然后直接输入管理员密码，按回车（输入时，电脑上不会有显示，直接输入，输入完回车即可，如果管理员未设置密码，请在系统偏好设置-帐户-更改密码中设置一个密码，这很重要，一定要设置一个有密码的帐户）回车后，会再出现一行提示，输入Y，然后回车，此时，就会开始制作安装盘，大概在20-30分钟左右完成。中间请不要让电脑待机。1sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app 制作中：制作完成：完成以上三步之后，U盘系统盘就制作完毕，打开U盘，将会看到有安装的系统；如下： Mac系统的安装操作这一步之前，请您先备份一下当前电脑里的重要资料 重启电脑，马上按住Command (⌘) ＋option＋R键。如果未接入互联网，请从地球仪图标的下方选取一个WIFI网络并连接。（此步骤通常需要20-30分钟的下载时间，此时间可能会根据网速有所不同） 下载完成后会进入“OS X实用工具”选择“磁盘工具”，然后点按“继续”。 在左侧选择您的硬盘（通常是磁盘工具对话框左侧首位顶格的磁盘），然后点按右侧“抹掉”标签。 从“格式化”菜单中选取“Mac OS 扩展（日志式）”，输入名称来命名磁盘，然后点按右下角“抹掉”。 磁盘完成抹掉后，请选取位于整个屏幕的左上角菜单“磁盘工具”&gt;“退出磁盘工具”，并重启电脑。 重启电脑时，按住option键，选择U盘引导安装盘安装OS X系统，按提示操作，等待完成系统安装。]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发(二)之swift中的json序列化]]></title>
    <url>%2F2016%2F04%2F27%2F2016-04-27%2F</url>
    <content type="text"><![CDATA[失败了我不后悔，但我一定后悔没有去尝试 - 杰夫 贝索斯 JSON是JavaScript Object Notation的缩写，它是一种轻量级的数据格式，一般用于数据交互，服务器返回给客户端的数据，一般是JSON格式或者XML格式（文件下载除外）。 然而在app开发中，我们需要将用户设置的数据上传到后台。我们根据后台提供的接口文档，有些参数往往需要将一些字典和数组需要先转为json格式的然后上传，以方便后台进行处理！ 虽然oc和swift语言中都是使用苹果提供的NSJSONSerialization类来json序列化，但是swift处理还是与OC有所不同的，所以今天分享swift中json序列化。 我将以艺学教师版中老师将教学科目设置好之后保存到后台服务器为例： 如下图我需要将红框内的已选科目上传到后台： 后台提供的接口文档描述如下： 下面的代码是点击保存之后上传数据到后台12345678910111213141516171819202122232425262728293031323334353637383940var arr = [[String: AnyObject]]()for selModel in selectedList &#123; // var selectedList = [TeachSubjectEntity]() // 已选科目 var dict = [String: AnyObject]() dict["son_name"] = selModel.cname for model in dataList &#123; if selModel.pid == model.ID &#123; // var dataList = [TeachSubjectEntity]() // 所有分类 dict["parent_name"] = model.cname &#125; &#125; arr.append(dict)&#125;var params = [String: AnyObject]()params["token"] = Tokenparams["id"] = YXAccount.sharedAccount().IDdo &#123; let list = try NSJSONSerialization.dataWithJSONObject(arr, options: .PrettyPrinted) let listJson = NSString(data: list, encoding: NSUTF8StringEncoding) params["list"] = listJson&#125; catch &#123; print(error)&#125; YXHttpTool.post(AddTeachSubjectURL, params: params, success: &#123; (JSON) in if let dict = JSON as? [String: NSObject], code = dict["code"], msg = dict["msg"]&#123; SVProgressHUD.setMinimumDismissTimeInterval(0.8) if code == "0" &#123; SVProgressHUD.showSuccessWithStatus("保存成功") dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (Int64)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), &#123; self.navigationController?.popViewControllerAnimated(true) &#125;) &#125; else &#123; SVProgressHUD.showErrorWithStatus(msg as! String) &#125; &#125; &#125;) &#123; &#125; 其中下面这段代码就是将数组转为json格式的， swift2.0之后就必须以抛出一个异常的方式来转json字符串， 下面的思路是先将数组转为NSData，再进一步转为JSonString。1234567do &#123; let list = try NSJSONSerialization.dataWithJSONObject(arr, options: .PrettyPrinted) let listJson = NSString(data: list, encoding: NSUTF8StringEncoding) params["list"] = listJson&#125; catch &#123; print(error)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac开发中的小技巧]]></title>
    <url>%2F2016%2F04%2F26%2F2016-04-26%2F</url>
    <content type="text"><![CDATA[终端颜色设置 设置终端vim编辑器的脚本文件.vimrc，该文件只能放在家目录（~），打开一个终端（默认是停留在家目录） ，在命令行中输入sudo vim .vimrc将以下内容复制到里面 123456789syntax on &quot;语法支持&quot; set hlsearch &quot;检索时高亮显示匹配项&quot;set number &quot;显示行号&quot; set ruler &quot;显示光标当前所在位置，及横纵坐标&quot; set tabstop=4 &quot;设置tab键缩进空格数，默认缩进8个空格&quot; set softtabstop=4 &quot;协调tabstop和shift width&quot; set shiftwidth=4 &quot;设置自动缩进的空格数&quot;、 set smartindent &quot;智能对齐&quot;set showmatch &quot;让成对的字符显示匹配，例如光标放在’&#123;‘上,则与之匹配&apos;&#125;&apos;背景颜改变&quot; 设置终端命令ls显示项的颜色，在终端目录中输入下述命令alias ls=&#39;ls -G&#39; 设置终端背景颜色，在偏好设置中的描述文件设置即可，如下图，最护眼背景颜色是军绿色RGB值为199 237 204 清除Xcode不必要的缓存文件打开终端，输入如下命令(xcq替换为自己的用户名)open /Users/xcq/Library/Developer/Xcode/iOS\ DeviceSupport如下图，留下9.3.1文件夹，删除其余的，可以为你的Mac清理腾出几十G的文件（放心，我都操作过了，用Xcode运行项目不会报错，只不过清楚之后第一次编译会变慢） Xcode快捷键总结1234567891011121314151617181920212223242526command + shift + N 创建一个Projectcommand + option + N 新建一个Groupcommand + option + enter 打开分页窗口file—&gt;new—&gt;Target 一个工程里面新建几个文件（add Target）command + shift + k clear项目ßcommand + [/] 向左对齐,向右对齐command + option + [ / ] 代码上移：command + F 搜索command + R 编译并运行程序command + shift + y 显示/隐藏debug区command + / 添加或解除注释command + 0 隐藏左栏ßcommand + option + 0 隐藏右栏command + 1-8 导航栏command + A 全选contrl + i 格式化选中代码command + N 直接调出创建文件的窗口command + option + control + 1-4 右下角的库面板command + control + 上/下 ；从.m切换到.hcommand + shift + N 创建一个Projectcommand + Shift + 0 (Zero) 文档和参考option + command + &lt;— 收起option + command + —&gt; 展开command + shift + o(字母o) 搜索类或者文件command + shift + j 快速定位到这个类文件所处位置]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发(一)之OC过渡到Swift开发]]></title>
    <url>%2F2016%2F04%2F26%2F2016-04-26-21-55%2F</url>
    <content type="text"><![CDATA[“我最大的动力？”时刻挑战自己。我把生活视为用不毕业的大学，每天我求知若渴。 - 理查德 布兰森 今天打开简书一看，发现自己写的文章都是停留在一个月前，上一个月我主要是在做公司艺学教师版的国际版本的app。这也没办法啊，项目太紧张了，累得要死，每天工作到晚上十点。一方面是时间紧张，另一方面是我想用swift重写整个项目，既可以检验下自己之前学习swift的效果，又通过项目真正提升自己swift编程能力。毕竟swift是趋势，下图是2016年4月TIOBE编程语言排行榜，足以说明学习swift的重要性，我们得紧跟着时代的的步伐。尽管工作辛苦，但是和大家分享我的学习之路，我是非常的happy的。我今天分享的主要是使用oc和swift混合编程中需要注意的细节。记录自己的学习路线，更重要的是让后学者可以少走很多坑！ 总之，我使用swift写程序的感觉就是，一个字：爽；两个字：很爽；三个字：非常爽。写的代码程序是非常的简洁，也非常适合一些初学者学习，入门比OC低太多了。 注意点一：使用cocoapods管理第三方库，请添加use_frameworks！use_frameworks！use_frameworks！重要的事情说三遍在 Swift 项目中，cocoapod 仅支持以 Framework 方式添加框架，因此需要在 Podfile 中添加 use_frameworks！下面是我的Podfile文件，最后一个是swift的网络请求框架。12345678910use_frameworks!pod &apos;AFNetworking&apos;pod &apos;SDWebImage&apos;pod &apos;SVProgressHUD&apos;pod &apos;MJRefresh&apos;pod &apos;MJExtension&apos;pod &apos;KLCPopup&apos;pod &apos;UPYUN&apos;, &apos;~&gt; 1.0.0&apos;pod &apos;HyphenateFullSDK&apos;, &apos;~&gt; 3.1.1&apos;pod &apos;Alamofire&apos;, &apos;~&gt; 3.3.1&apos; 如果你的Podfile文件里面没有写 use_frameworks!在pod update时候将会出现下面的错误：在使用的时候你得在每个swift类中import 相应的第三方库就可以使用了，这也是其麻烦之处；比如我的项目中很多页面都需要使用SVProgressHUD 显示一些信息，那么我就必须在这些类中都写这句代码引入这个库 import SVProgressHUD 按理来说，我在桥接文件中包含过一次就应该好了，但是我却一直不成功，希望解决这个问题的人，相互交流下！ 注意点二：swift调用OC代码建立一个桥接文件，有两种方法：方法一：新建一个oc的类，xcode会自动提示你建立一个桥接文件，然后将新建的oc类给删除就可以了，然后将需要在swift中调用的oc类的类名包含进来即可； 方法二：自己新建一个桥接头文件，File &gt; New &gt; File &gt; (iOS) &gt; Source &gt; Header File，之后还得配置下桥接文件的路径，如下图所示，将新建的头文件路径添加进来就行了。 注意点三：OC调用swift代码oc调用swift的类需要在.m文件中包含头文件 #import &quot;&lt;#YourProjectName#&gt;-Swift.h&quot; 例如我的项目名称叫YXTeacherEn，所以包含的头文件叫 #import &quot;YXTeacherEn-Swift.h&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用oschina托管自己项目]]></title>
    <url>%2F2016%2F03%2F29%2F2016-03-29%2F</url>
    <content type="text"><![CDATA[好的程序猿之所以编程，不是为了赚大钱或装逼，而是纯粹享受其中。 众所周知，开源中国社区 http://git.oschina.net 是一个为中国的IT技术人员提供一个全面的、快捷更新的用来检索开源软件以及交流使用开源经验的平台，是目前中国最大的开源技术社区。相比于GitHub，由于他的服务器在国内，访问速度更快，更主要是可以免费建立私有项目； 下面就分享下自己今天用Mac电脑在oschina上托管自己私有项目的步骤，本文主要包含以下两大内容： 托管新建项目 托管已有项目 托管新建项目一、配置SSH key 第一步：注册账号，点击这里：http://git.oschina.net 进行注册（这步骤就不啰嗦了，地球人都知道） 第二步：添加SSH公钥（SSH key可以让你在你的电脑和 Git @ OSC 之间建立安全的加密连接，开源中国帮助文档地址：https://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys） 打开终端，按照如下命令来生成ssh-keys ，xxxxx@xxxxx.com 就用你的注册邮箱就可以了， ssh-keygen -t rsa -C “xxxxx@xxxxx.com” 出现Enter file in which to save the key (/Users/xcq/.ssh/id_rsa): 时，直接回车就行（为了方便全程回车，可以不用输入rss文件名和密码）；如果之前已经添加过ssh-keys将出现以下提示：直接出入n,然后回车，避免重复添加！ 输入以下命令，查看你的public key（下图红色括号的内容），并把他添加到 Git @ OSC http://git.oschina.net/keys cat ~/.ssh/id_rsa.pub 添加后，在终端（Terminal）中输入 ssh -T git@git.oschina.net 若返回 Welcome to Git@OSC, yourname! 则证明添加成功。 二、在oschina上面新建项目 http://git.oschina.net 登录自己账号之后，进行如下操作： 注意：开源许可协议选择 MIT License ， GitIgnore可以选择也可以不选择，不选择则需有第三大步（三、添加gitignore）的配置， 点击创建之后，跳转到如下页面： 拷贝ssh地址，先用终端命令cd（我这是cd /Users/xcq/Desktop/YiXueCompany ） 改变当前目录为你需要托管的项目目录文件下，然后在终端输入如下指令（其中git@git.oschina.net:xxx/ProjectName.git为你拷贝的ssh地址） $ git clone git@git.oschina.net:xxx/ProjectName.git 三、添加gitignore （如果在上一步,，即二、在oschina上面新建项目时添加了.gitignore文件，则此步略过）注：添加 .gitignore 文件之后每次提交时不会将个人的项目设置信息（例如：末次打开的文件，调试断点等）提交到服务器，在团队开发中非常重要 打开https://github.com/github/gitignore 下载gitignore项目文件，里面包含了各种语言的gitignore配置； 打开终端， 改变当前目录为你需要托管的项目目录文件下，输入以下命令（其中/Users/xcq/Downloads/gitignore-master/Swift.gitignore为刚刚下载的gitignore路径，我这里是新建的swift项目，所以选择Swift.gitignore） cp /Users/xcq/Downloads/gitignore-master/Swift.gitignore .gitignoregit add . # 将修改添加至暂存区git commit -m”添加gitignore” # 提交修改并且添加备注信息git push # 将修改推送到远程服务器 四、新建项目 用xcode新建swift项目，保存到托管的项目目录，还有点要注意就是不要勾选 提交的时候勾选，就会提交到oschina上面建立的远程仓库。 已上四步是教你如何将一个全新的项目添加到oschina；还有一种需求那就是将已有的本地项目上传到oschina 托管已有项目，即将已有的本地项目上传到oschina 前三步的操作与上面一样； 接下来，做以下操作：打开终端，切换到你的项目目录下，依次输入以下命令 git init .git pull git@git.oschina.net:xxxx/Demo.gitgit add -A .git commit -am “纳入版本控制”sgit push git@git.oschina.net:xxxxxxx/Demo.git master 其中git@git.oschina.net:xxxx/Demo.git就是你新建远程仓库的地址，即step7.png图片的地址。 完毕，✌️✌️✌️，分享是一种美德，坚持就是胜利，坚持分享自己的学习点滴！]]></content>
      <tags>
        <tag>oschina</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑双系统的安装]]></title>
    <url>%2F2016%2F03%2F22%2F2016-03-22%2F</url>
    <content type="text"><![CDATA[昨天公司一个做文秘的同事由于公司给配的电脑很不给力，用个office，再打开一两个其他的软件就卡的要死，最后实在是受不了，就差砸电脑了。所以只好把她12年末买的一款2012年中的MacBook Pro拿过来准备安装win7（mac电脑虽好，但是对于经常用office做编辑的人来说，mac电脑显然不能够满足工作的需要），看了她macPro的配置(处理器：2.9 GHz Intel Core i7，8 GB内存，硬盘容量750G)之后第一反应是真土豪啊，居然把这么好的电脑藏在家中不用，太浪费了。虽然之前也没安装双系统，但是作为一个程序猿技术男，此时正是一展身手的好机会啊，好让妹子们也崇拜下咋们，给咋们程序猿长长脸。 前言本篇文章将教你一步一步在MAC电脑使用 Boot Camp 安装windows系统，尽管作为一个iOS开发者用mac笔记本确实体验很好，但是有时确实有特殊的需求需要用windows系统。(本文将以Mac机型为：MacBook Pro 13 英寸，2012 年中 的电脑安装win7 64位为例演示，切记：安装windows系统之前必须先确定你的mac电脑能否匹配windows系统版本，点击这里查看) 准备工作 一个64位的win7的ISO镜像文件，点击这里下载我在百度云盘共享一个win7镜像；(反正就是得下载一个靠谱的iso镜像，我第一次安装失败就是因为在网上随便下载的镜像是坏的，导致最后提示window未能启动) 两个U盘或者移动硬盘，一个16G已上 MS-DOS (FAT) 格式的作为系统安装盘，和一个8G已上 MS-DOS (FAT) 格式的的装驱动程序的驱动盘。有移动硬盘尽量用移动硬盘，因为速度快，为你节省时间；(第一次操作过程很慢的一部分原因的就是因为U盘不给力，导致整个安装过程非常慢，后面果断换成的) 互联网连接，网速越快，安装过程速度越快！(白天第一次安装失败，过程慢，等得我是非常痛苦，下班后果断回家弄，100M的网，这速度溜溜的，整个过程不到两小时就安装好了) 。 首次安装 Windows 时，建议留出 30 GB 可用磁盘空间，如果您是从之前版本的 Windows 升级，则建议留出 40 GB 的可用磁盘空间 win7系统安装一、系统安装盘的准备：(此步骤在需要安装双系统的mac电脑上操作) 插入系统盘，将之前下载好的win7的ISO镜像文件拷贝到桌面，然后删除系统盘的ISO镜像文件，是系统盘成为空白盘； 用Spotlight搜索Boot Camp助理，或者打开launchpad–》其他–》Boot Camp助理 ,打开的界面如下： 点击继续，按下图进行勾选（切记只勾选前两个，最后一个不要勾选） 点击继续，出现以下界面点击选取，选择之前保存在mac电脑桌面的ISO镜像文件，目的磁盘就是那个系统安装盘，并且保持与你的Mac的连接，直到windows安装完成 点击继续，会出现以下界面（整个过程将会持续至少半个小时，这取决于你的U盘和网速，我在这步都要疯掉了，等了一个多小时都没成功，果断换了新的U盘和100M网络） step4.jpg完成之后，会弹出以下界面： 至此为止，系统安装盘已经准备好了，点击退出关闭“Boot Camp助理”窗口以退出此应用。 二、驱动盘的准备：(因为上一步骤需要部分时间，所以在进行上一步骤的同时，你可以另一台电脑上面进行此步骤的操作，节省时间) 从苹果官网上按Mac机型列出的BootCamp要求来查找您所用的 Windows 版本和 Mac 所需的 Windows 支持软件（驱动程序）如下图： 点击step6.png红色箭头指向的‘5’将跳转到下载页面，如下图： 点击下载，得到的是zip包，解压之后的BootCamp5文件夹（这就是需要下载的驱动程序）如下： 将上一步得到的BootCamp5文件保存到事先准备好的驱动盘中。 三、正式安装：（系统安装盘一直连接在电脑上，直到安装win7成功） 将驱动盘的BootCamp5文件拖动到系统安装盘中，在系统提示您是否要替换系统安装盘上的现有项目时，请点按“是”。 再次打开“Boot Camp 助理”，然后点按“继续”。 切记仅勾选第三个，即仅选择“安装 Windows7或更高版本”选项。 点击继续，然后按照屏幕提示重新对您的驱动器进行分区，然后安装 Windows。 完成该助理的操作后，Mac 会重新启动至 Windows 安装程序。 在系统询问您要在何处安装 Windows 时，请选择 BOOTCAMP 分区，然后点按“驱动器选项”，并对您的 Boot Camp 分区进行格式化。如下图： 点击下一步将出现以下界面：(此步骤也需要等待一段时间) 等待一段时间后，也就大功告成了。 四、安装驱动（因为到这步为止，电脑还不能联网，有线网，无线网络都连不上，所以我怀疑没有网卡驱动） 苹果官方给的操作步骤：window安装成功后但是还没有任何驱动，是不能上网的，这时需要安装系统盘中的驱动，按照step7给的步骤操作， 我实际的操作从我的驱动盘中找到并安装无线网卡驱动然后就可以上网了，如下图：最后交由驱动精灵来给我win7系统安装其他驱动和打系统补丁。到此你的mac电脑双系统也就安装成功了，可以愉快的玩耍了， 安装失败的解决方法 我第一次安装是失败了，在安装过程中出现了下图的问题，最后只好重新安装，并且换了一个win7系统镜像文件。第一步，此时需要先把电脑强制关机，就是按住电源键；第二步，再开机，听到开机声或者白屏之后按住option按键或者一直按住option键，直到看到启动磁盘选项，选择Mac的系统盘就可以了；第三步，进入 Boot Camp助理选项，前面的选项不要勾选，只勾选最后的删除win选项，第四步，重新按照我说的步骤操作进行win7系统安装。 我们终此一生，就是要摆脱他人的期待，找到真正的自己; 记录学习的点滴，以此勉励不断奋斗的自己✌️✌️✌️]]></content>
      <tags>
        <tag>双系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac电脑的PHP开发环境配置]]></title>
    <url>%2F2016%2F03%2F08%2F2016-03-08%2F</url>
    <content type="text"><![CDATA[前言刚过完年，项目事情不多，老大叫我们趁着这段闲暇时间多学点其他知识，于是我和另一个iOS伙伴一起学习PHP知识，但是遇到一个问题：那就是mac 电脑的php环境配置。所以就整理了下配置方法，希望对以后的学习者可以上手更快，不要像我们一样倒腾的半天。 需要什么？ 安装 web 服务器； 安装 PHP； 安装数据库，比如Navigate Premium, MySQL。 因为mac电脑 的OS X系统已经自带apache和php，所以只要创建.php 文件，然后上传到 web 目录中即可。服务器会自动对它们进行解析。所以你无需编译或安装任何额外的工具。下面是具体的步骤。 apache配置1、我们需要手动开启apache服务，打开终端输入以下命令：sudo apachectl start ；手动开启后，在浏览器中输入localhost或者127.0.0.1 后会显示“It works!” 字样，则说明Apache服务开启成功；如下图：2、修改Apache的配置文件 ,终端中输入以下命令:sudo vim/etc/apache2/httpd.conf，然后输入电脑密码就可以进入编辑了；找到#LoadModule php5_module libexec/apache2/libphp5.so，去掉前面的注释符“#”(这里涉及一些mac终端终端命令懂一些基本命令就可以了,这里的话按i进入编辑模式,按Esc退出编辑模式，然后输入:wq退出vim并且保存修改)；如下图：3、已上两步之后，在终端输入命令： sudo apachectl restart ；我们就可以重启下Apache，至此Apache就已经配置好了。4、下面就可以写个简单“hello word！”php程序来检验下。Mac OS 的Apache2的默认根目录：/Library/WebServer/Documents；我们可以在这个目录下新建.php文件，但是在此之前我们最好先安装一个php编辑器，不然用vim 编辑器没那么方便；我用的是Sublime Text2，大家可以在Sublime Text官网下载。 打开终端输入一下两条命令：touch /Library/WebServer/Documents/hello.phpopen /Library/WebServer/Documents/hello.php输入&lt;?phpecho “hello word!”;?&gt; 安装数据库（Navigate Premium）具体安装我就不说了，网上有很多教程；start MySQL Server 如图： 新建数据库 密码不用填写： 到此环境就配好了，大家可以写程序了！！！数据库的安装写的比较简单，主要因为网上教程很多，而且不同开发人员用的工具都不一样，所以一笔带过。]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
</search>
